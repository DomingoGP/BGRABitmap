{ This file is generated by dev/colorspace/UnitMaker program }

{$IFDEF INCLUDE_INTERFACE}
{$UNDEF INCLUDE_INTERFACE}
type

  {TStdRGBA}
  PLabA       = ^TLabA;
  PXYZA       = ^TXYZA;
  PLinearRGBA = ^TLinearRGBA;
  PStdCMYK    = ^TStdCMYK;
  PStdHSVA    = ^TStdHSVA;
  PStdHSLA    = ^TStdHSLA;
  PAdobeRGBA  = ^TAdobeRGBA;
  PStdRGBA    = ^TStdRGBA;
  PLChA       = ^TLChA;

  TStdRGBA = packed record
    red,green,blue,alpha: single;
    class function New(const ARed,AGreen,ABlue,AAlpha:single): TStdRGBA;overload;static;
    class function New(const ARed,AGreen,ABlue:single): TStdRGBA;overload;static;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor)   : TStdRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : TColor;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : TBGRAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : TExpandedPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : THSLAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : TGSBAPixel;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : PLinearRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : PAdobeRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : PStdHSLA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : PStdHSVA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : PStdCMYK;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : PXYZA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : PLabA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA) : PLChA;
  end;
  
  {TAdobeRGBA}
  TAdobeRGBA = packed record
    red,green,blue,alpha: byte;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor)     : TAdobeRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : TColor;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : TBGRAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : TStdRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : TExpandedPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : THSLAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : TGSBAPixel;
    class function New(const ARed,AGreen,ABlue,AAlpha:byte): TAdobeRGBA;overload;static;
    class function New(const ARed,AGreen,ABlue:byte): TAdobeRGBA;overload;static;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : PStdHSLA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : PStdHSVA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : PStdCMYK;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : PLinearRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : PXYZA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : PLabA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA) : PLChA;
  end;
  
  {TStdHSLA}
  TStdHSLA = packed record
    hue,saturation,lightness,alpha: single;
    class function New(const AHue,ASaturation,ALightness,AAlpha:single): TStdHSLA;overload;static;
    class function New(const AHue,ASaturation,ALightness:single): TStdHSLA;overload;static;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor)   : TStdHSLA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : TColor;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : TBGRAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : TStdRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : TAdobeRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : TExpandedPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : THSLAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : TGSBAPixel;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : PStdHSVA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : PStdCMYK;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : PLinearRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : PXYZA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : PLabA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA) : PLChA;

  end;
  
  {TStdHSVA}
  TStdHSVA = packed record
    hue,saturation,value,alpha: single;
    class function New(const AHue,ASaturation,AValue,AAlpha:single): TStdHSVA;overload;static;
    class function New(const AHue,ASaturation,AValue:single): TStdHSVA;overload;static;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor)   : TStdHSVA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : TColor;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : TBGRAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : TStdRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : TAdobeRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : TStdHSLA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : TExpandedPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : THSLAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : TGSBAPixel;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : PStdCMYK;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : PLinearRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : PXYZA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : PLabA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA) : PLChA;
  end;
  
  {TStdCMYK}
  TStdCMYK = packed record
    C,M,Y,K: single;
    class function New(const ACyan,AMagenta,AYellow,ABlack:single): TStdCMYK;static;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor)   : TStdCMYK;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : TColor;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : TBGRAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : TStdRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : TAdobeRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : TStdHSLA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : TStdHSVA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : TExpandedPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : THSLAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : TGSBAPixel;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : PLinearRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : PXYZA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : PLabA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK) : PLChA;
  end;
  
  {TLinearRGBA}
  TLinearRGBA = packed record
    red,green,blue,alpha: single;
    class function New(const ARed,AGreen,ABlue,AAlpha:single): TLinearRGBA;overload;static;
    class function New(const ARed,AGreen,ABlue:single): TLinearRGBA;overload;static;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor)      : TLinearRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : TColor;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : TBGRAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : TStdRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : TAdobeRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : TStdHSLA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : TStdHSVA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : TStdCMYK;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : TExpandedPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : THSLAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : TGSBAPixel;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : PXYZA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : PLabA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA) : PLChA;
  end;
  
  {TXYZA}
  TXYZA = packed record
    X,Y,Z,alpha: single;
    class function New(const AX,AY,AZ,AAlpha:single): TXYZA;overload;static;
    class function New(const AX,AY,AZ:single): TXYZA;overload;static;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor): TXYZA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : TColor;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : TBGRAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : TStdRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : TAdobeRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : TStdHSLA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : TStdHSVA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : TStdCMYK;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : TExpandedPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : TLinearRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : THSLAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : TGSBAPixel;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : PLabA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA) : PLChA;
  end;
  
  {TLabA}
  TLabA = packed record
    L,a,b,alpha: single;
    class function New(const ALightness,Aa,Ab,AAlpha:single): TLabA;overload;static;
    class function New(const ALightness,Aa,Ab:single): TLabA;overload;static;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor): TLabA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : TColor;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : TBGRAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : TStdRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : TAdobeRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : TStdHSLA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : TStdHSVA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : TStdCMYK;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : TExpandedPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : TLinearRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : THSLAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : TGSBAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : TXYZA;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA) : PLChA;
  end;
  
  {TLChA}
  TLChA = packed record
    L,C,h,alpha: single;
    class function New(const ALightness,AChroma,AHue,AAlpha:single): TLChA;overload;static;
    class function New(const ALightness,AChroma,AHue:single): TLChA;overload;static;

    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TColor): TLChA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TColor;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TBGRAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TStdRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TAdobeRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TStdHSLA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TStdHSVA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TStdCMYK;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TExpandedPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TLinearRGBA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : THSLAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TGSBAPixel;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TXYZA;
    class operator {$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF} (const AValue: TLChA) : TLabA;
  end;
  
  { TColorColorspace }
  
  TColorColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TBGRAPixelColorspace }
  
  TBGRAPixelColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TStdRGBAColorspace }
  
  TStdRGBAColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TAdobeRGBAColorspace }
  
  TAdobeRGBAColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TStdHSLAColorspace }
  
  TStdHSLAColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TStdHSVAColorspace }
  
  TStdHSVAColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TStdCMYKColorspace }
  
  TStdCMYKColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TExpandedPixelColorspace }
  
  TExpandedPixelColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TLinearRGBAColorspace }
  
  TLinearRGBAColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { THSLAPixelColorspace }
  
  THSLAPixelColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TGSBAPixelColorspace }
  
  TGSBAPixelColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TXYZAColorspace }
  
  TXYZAColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TLabAColorspace }
  
  TLabAColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  { TLChAColorspace }
  
  TLChAColorspace = class(TCustomColorspace)
    class function GetChannelName(AIndex: integer): string; override;
    class function GetChannelCount: integer; override;
    class function GetMaxValue(AIndex: integer): single; override;
    class function GetMinValue(AIndex: integer): single; override;
    class function GetName: string; override;
    class function GetSize: integer; override;
    class function GetChannel(AColor: Pointer; AIndex: integer): single; override;
    class procedure SetChannel(AColor: Pointer; AIndex: integer; AValue: single); override;
    class function HasReferenceWhite: boolean; override;
  end;
  
  {$IFDEF OBJ}
  {TColorHelper}
  
  TColorHelper = type helper for TColor
    class function New(const ARed,AGreen,ABlue:byte): TColor;static;
    class function Colorspace: TColorspaceAny; static;
  private
    function GetRed: byte;
    function GetGreen: byte;
    function GetBlue: byte;
    procedure SetRed(AValue: byte);
    procedure SetGreen(AValue: byte);
    procedure SetBlue(AValue: byte);
  public
    function ToBGRAPixel: TBGRAPixel;overload;
    function ToBGRAPixel(AAlpha: byte): TBGRAPixel;overload;
    function ToStdRGBA: TStdRGBA;overload;
    function ToStdRGBA(AAlpha: single): TStdRGBA;overload;
    function ToAdobeRGBA: TAdobeRGBA;overload;
    function ToAdobeRGBA(AAlpha: byte): TAdobeRGBA;overload;
    function ToStdHSLA: TStdHSLA;overload;
    function ToStdHSLA(AAlpha: single): TStdHSLA;overload;
    function ToStdHSVA: TStdHSVA;overload;
    function ToStdHSVA(AAlpha: single): TStdHSVA;overload;
    function ToStdCMYK: TStdCMYK;
    function ToExpandedPixel: TExpandedPixel;overload;
    function ToExpandedPixel(AAlpha: BGRAWord): TExpandedPixel;overload;
    function ToLinearRGBA: TLinearRGBA;overload;
    function ToLinearRGBA(AAlpha: single): TLinearRGBA;overload;
    function ToHSLAPixel: THSLAPixel;overload;
    function ToHSLAPixel(AAlpha: BGRAWord): THSLAPixel;overload;
    function ToGSBAPixel: TGSBAPixel;overload;
    function ToGSBAPixel(AAlpha: BGRAWord): TGSBAPixel;overload;
    function ToXYZA: TXYZA;overload;
    function ToXYZA(AAlpha: single): TXYZA;overload;
    function ToLabA: TLabA;overload;
    function ToLabA(AAlpha: single): TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(AAlpha: single): TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromBGRAPixel(AValue: TBGRAPixel);
    procedure FromStdRGBA(AValue: TStdRGBA);
    procedure FromAdobeRGBA(AValue: TAdobeRGBA);
    procedure FromStdHSLA(AValue: TStdHSLA);
    procedure FromStdHSVA(AValue: TStdHSVA);
    procedure FromStdCMYK(AValue: TStdCMYK);
    procedure FromExpandedPixel(AValue: TExpandedPixel);
    procedure FromLinearRGBA(AValue: TLinearRGBA);
    procedure FromHSLAPixel(AValue: THSLAPixel);
    procedure FromGSBAPixel(AValue: TGSBAPixel);
    procedure FromXYZA(AValue: TXYZA);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
    property red: byte read GetRed write SetRed;
    property green: byte read GetGreen write SetGreen;
    property blue: byte read GetBlue write SetBlue;
  end;
  {$ENDIF}  
  {TBGRAPixelHelper}
  
  TBGRAPixelHelper = record helper{$IFDEF OBJ}(TBGRAPixelBasicHelper){$ENDIF} for TBGRAPixel
    class function New(const ARed,AGreen,ABlue,AAlpha:byte): TBGRAPixel;overload;static;
    class function New(const ARed,AGreen,ABlue:byte): TBGRAPixel;overload;static;
    class function Colorspace: TColorspaceAny; static;
    function ToStdRGBA: TStdRGBA;
    function ToAdobeRGBA: TAdobeRGBA;
    function ToStdHSLA: TStdHSLA;
    function ToStdHSVA: TStdHSVA;
    function ToStdCMYK: TStdCMYK;
    function ToLinearRGBA: TLinearRGBA;
    function ToXYZA: TXYZA;
    function ToLabA: TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromStdRGBA(AValue: TStdRGBA);
    procedure FromAdobeRGBA(AValue: TAdobeRGBA);
    procedure FromStdHSLA(AValue: TStdHSLA);
    procedure FromStdHSVA(AValue: TStdHSVA);
    procedure FromStdCMYK(AValue: TStdCMYK);
    procedure FromLinearRGBA(AValue: TLinearRGBA);
    procedure FromXYZA(AValue: TXYZA);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
  end;
  
  {TStdRGBAHelper}
  
  TStdRGBAHelper = record helper for TStdRGBA
    class function Colorspace: TColorspaceAny; static;
    function ToColor: TColor;
    function ToBGRAPixel: TBGRAPixel;
    function ToAdobeRGBA: TAdobeRGBA;
    function ToStdHSLA: TStdHSLA;
    function ToStdHSVA: TStdHSVA;
    function ToStdCMYK: TStdCMYK;
    function ToExpandedPixel: TExpandedPixel;
    function ToLinearRGBA: TLinearRGBA;
    function ToHSLAPixel: THSLAPixel;
    function ToGSBAPixel: TGSBAPixel;
    function ToXYZA: TXYZA;
    function ToLabA: TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromColor(AValue: TColor);
    procedure FromBGRAPixel(AValue: TBGRAPixel);
    procedure FromAdobeRGBA(AValue: TAdobeRGBA);
    procedure FromStdHSLA(AValue: TStdHSLA);
    procedure FromStdHSVA(AValue: TStdHSVA);
    procedure FromStdCMYK(AValue: TStdCMYK);
    procedure FromExpandedPixel(AValue: TExpandedPixel);
    procedure FromLinearRGBA(AValue: TLinearRGBA);
    procedure FromHSLAPixel(AValue: THSLAPixel);
    procedure FromGSBAPixel(AValue: TGSBAPixel);
    procedure FromXYZA(AValue: TXYZA);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
  end;
  
  {TAdobeRGBAHelper}
  
  TAdobeRGBAHelper = record helper for TAdobeRGBA
    class function Colorspace: TColorspaceAny; static;
    function ToColor: TColor;
    function ToBGRAPixel: TBGRAPixel;
    function ToStdRGBA: TStdRGBA;
    function ToStdHSLA: TStdHSLA;
    function ToStdHSVA: TStdHSVA;
    function ToStdCMYK: TStdCMYK;
    function ToExpandedPixel: TExpandedPixel;
    function ToLinearRGBA: TLinearRGBA;
    function ToHSLAPixel: THSLAPixel;
    function ToGSBAPixel: TGSBAPixel;
    function ToXYZA: TXYZA;
    function ToLabA: TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromColor(AValue: TColor);
    procedure FromBGRAPixel(AValue: TBGRAPixel);
    procedure FromStdRGBA(AValue: TStdRGBA);
    procedure FromStdHSLA(AValue: TStdHSLA);
    procedure FromStdHSVA(AValue: TStdHSVA);
    procedure FromStdCMYK(AValue: TStdCMYK);
    procedure FromExpandedPixel(AValue: TExpandedPixel);
    procedure FromLinearRGBA(AValue: TLinearRGBA);
    procedure FromHSLAPixel(AValue: THSLAPixel);
    procedure FromGSBAPixel(AValue: TGSBAPixel);
    procedure FromXYZA(AValue: TXYZA);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
  end;
  
  {TStdHSLAHelper}
  
  TStdHSLAHelper = record helper for TStdHSLA
    class function Colorspace: TColorspaceAny; static;
    function ToColor: TColor;
    function ToBGRAPixel: TBGRAPixel;
    function ToStdRGBA: TStdRGBA;
    function ToAdobeRGBA: TAdobeRGBA;
    function ToStdHSVA: TStdHSVA;
    function ToStdCMYK: TStdCMYK;
    function ToExpandedPixel: TExpandedPixel;
    function ToLinearRGBA: TLinearRGBA;
    function ToHSLAPixel: THSLAPixel;
    function ToGSBAPixel: TGSBAPixel;
    function ToXYZA: TXYZA;
    function ToLabA: TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromColor(AValue: TColor);
    procedure FromBGRAPixel(AValue: TBGRAPixel);
    procedure FromStdRGBA(AValue: TStdRGBA);
    procedure FromAdobeRGBA(AValue: TAdobeRGBA);
    procedure FromStdHSVA(AValue: TStdHSVA);
    procedure FromStdCMYK(AValue: TStdCMYK);
    procedure FromExpandedPixel(AValue: TExpandedPixel);
    procedure FromLinearRGBA(AValue: TLinearRGBA);
    procedure FromHSLAPixel(AValue: THSLAPixel);
    procedure FromGSBAPixel(AValue: TGSBAPixel);
    procedure FromXYZA(AValue: TXYZA);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
  end;
  
  {TStdHSVAHelper}
  
  TStdHSVAHelper = record helper for TStdHSVA
    class function Colorspace: TColorspaceAny; static;
    function ToColor: TColor;
    function ToBGRAPixel: TBGRAPixel;
    function ToStdRGBA: TStdRGBA;
    function ToAdobeRGBA: TAdobeRGBA;
    function ToStdHSLA: TStdHSLA;
    function ToStdCMYK: TStdCMYK;
    function ToExpandedPixel: TExpandedPixel;
    function ToLinearRGBA: TLinearRGBA;
    function ToHSLAPixel: THSLAPixel;
    function ToGSBAPixel: TGSBAPixel;
    function ToXYZA: TXYZA;
    function ToLabA: TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromColor(AValue: TColor);
    procedure FromBGRAPixel(AValue: TBGRAPixel);
    procedure FromStdRGBA(AValue: TStdRGBA);
    procedure FromAdobeRGBA(AValue: TAdobeRGBA);
    procedure FromStdHSLA(AValue: TStdHSLA);
    procedure FromStdCMYK(AValue: TStdCMYK);
    procedure FromExpandedPixel(AValue: TExpandedPixel);
    procedure FromLinearRGBA(AValue: TLinearRGBA);
    procedure FromHSLAPixel(AValue: THSLAPixel);
    procedure FromGSBAPixel(AValue: TGSBAPixel);
    procedure FromXYZA(AValue: TXYZA);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
  end;
  
  {TStdCMYKHelper}
  
  TStdCMYKHelper = record helper for TStdCMYK
    class function Colorspace: TColorspaceAny; static;
    function ToColor: TColor;
    function ToBGRAPixel: TBGRAPixel;overload;
    function ToBGRAPixel(AAlpha: byte): TBGRAPixel;overload;
    function ToStdRGBA: TStdRGBA;overload;
    function ToStdRGBA(AAlpha: single): TStdRGBA;overload;
    function ToAdobeRGBA: TAdobeRGBA;overload;
    function ToAdobeRGBA(AAlpha: byte): TAdobeRGBA;overload;
    function ToStdHSLA: TStdHSLA;overload;
    function ToStdHSLA(AAlpha: single): TStdHSLA;overload;
    function ToStdHSVA: TStdHSVA;overload;
    function ToStdHSVA(AAlpha: single): TStdHSVA;overload;
    function ToExpandedPixel: TExpandedPixel;overload;
    function ToExpandedPixel(AAlpha: BGRAWord): TExpandedPixel;overload;
    function ToLinearRGBA: TLinearRGBA;overload;
    function ToLinearRGBA(AAlpha: single): TLinearRGBA;overload;
    function ToHSLAPixel: THSLAPixel;overload;
    function ToHSLAPixel(AAlpha: BGRAWord): THSLAPixel;overload;
    function ToGSBAPixel: TGSBAPixel;overload;
    function ToGSBAPixel(AAlpha: BGRAWord): TGSBAPixel;overload;
    function ToXYZA: TXYZA;overload;
    function ToXYZA(AAlpha: single): TXYZA;overload;
    function ToLabA: TLabA;overload;
    function ToLabA(AAlpha: single): TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(AAlpha: single): TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromColor(AValue: TColor);
    procedure FromBGRAPixel(AValue: TBGRAPixel);
    procedure FromStdRGBA(AValue: TStdRGBA);
    procedure FromAdobeRGBA(AValue: TAdobeRGBA);
    procedure FromStdHSLA(AValue: TStdHSLA);
    procedure FromStdHSVA(AValue: TStdHSVA);
    procedure FromExpandedPixel(AValue: TExpandedPixel);
    procedure FromLinearRGBA(AValue: TLinearRGBA);
    procedure FromHSLAPixel(AValue: THSLAPixel);
    procedure FromGSBAPixel(AValue: TGSBAPixel);
    procedure FromXYZA(AValue: TXYZA);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
  end;
  
  {TExpandedPixelHelper}
  
  TExpandedPixelHelper = record helper{$IFDEF OBJ}(TExpandedPixelBasicHelper){$ENDIF} for TExpandedPixel
    class function New(const ARed,AGreen,ABlue,AAlpha:BGRAWord): TExpandedPixel;overload;static;
    class function New(const ARed,AGreen,ABlue:BGRAWord): TExpandedPixel;overload;static;
    class function Colorspace: TColorspaceAny; static;
    function ToStdRGBA: TStdRGBA;
    function ToAdobeRGBA: TAdobeRGBA;
    function ToStdHSLA: TStdHSLA;
    function ToStdHSVA: TStdHSVA;
    function ToStdCMYK: TStdCMYK;
    function ToLinearRGBA: TLinearRGBA;
    function ToXYZA: TXYZA;
    function ToLabA: TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromStdRGBA(AValue: TStdRGBA);
    procedure FromAdobeRGBA(AValue: TAdobeRGBA);
    procedure FromStdHSLA(AValue: TStdHSLA);
    procedure FromStdHSVA(AValue: TStdHSVA);
    procedure FromStdCMYK(AValue: TStdCMYK);
    procedure FromLinearRGBA(AValue: TLinearRGBA);
    procedure FromXYZA(AValue: TXYZA);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
  end;
  
  {TLinearRGBAHelper}
  
  TLinearRGBAHelper = record helper for TLinearRGBA
    class function Colorspace: TColorspaceAny; static;
    function ToColor: TColor;
    function ToBGRAPixel: TBGRAPixel;
    function ToStdRGBA: TStdRGBA;
    function ToAdobeRGBA: TAdobeRGBA;
    function ToStdHSLA: TStdHSLA;
    function ToStdHSVA: TStdHSVA;
    function ToStdCMYK: TStdCMYK;
    function ToExpandedPixel: TExpandedPixel;
    function ToHSLAPixel: THSLAPixel;
    function ToGSBAPixel: TGSBAPixel;
    function ToXYZA: TXYZA;
    function ToLabA: TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromColor(AValue: TColor);
    procedure FromBGRAPixel(AValue: TBGRAPixel);
    procedure FromStdRGBA(AValue: TStdRGBA);
    procedure FromAdobeRGBA(AValue: TAdobeRGBA);
    procedure FromStdHSLA(AValue: TStdHSLA);
    procedure FromStdHSVA(AValue: TStdHSVA);
    procedure FromStdCMYK(AValue: TStdCMYK);
    procedure FromExpandedPixel(AValue: TExpandedPixel);
    procedure FromHSLAPixel(AValue: THSLAPixel);
    procedure FromGSBAPixel(AValue: TGSBAPixel);
    procedure FromXYZA(AValue: TXYZA);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
  end;
  
  {THSLAPixelHelper}
  
  THSLAPixelHelper = record helper{$IFDEF OBJ}(THSLAPixelBasicHelper){$ENDIF} for THSLAPixel
    {$IFDEF BDS}
    function ToColor: TColor;
    procedure FromColor(const AValue: TColor);
    function ToBGRAPixel: TBGRAPixel;
    procedure FromBGRAPixel(AValue: TBGRAPixel);
    function ToGSBAPixel: TGSBAPixel;
    procedure FromGSBAPixel(AValue: TGSBAPixel);
    function ToExpanded: TExpandedPixel;
    procedure FromExpanded(AValue: TExpandedPixel);
    {$ENDIF}
    class function New(const AHue,ASaturation,ALightness,AAlpha:BGRAWord): THSLAPixel;overload;static;
    class function New(const AHue,ASaturation,ALightness:BGRAWord): THSLAPixel;overload;static;
    class function Colorspace: TColorspaceAny; static;
    function ToStdRGBA: TStdRGBA;
    function ToAdobeRGBA: TAdobeRGBA;
    function ToStdHSLA: TStdHSLA;
    function ToStdHSVA: TStdHSVA;
    function ToStdCMYK: TStdCMYK;
    function ToLinearRGBA: TLinearRGBA;
    function ToXYZA: TXYZA;
    function ToLabA: TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromStdRGBA(AValue: TStdRGBA);
    procedure FromAdobeRGBA(AValue: TAdobeRGBA);
    procedure FromStdHSLA(AValue: TStdHSLA);
    procedure FromStdHSVA(AValue: TStdHSVA);
    procedure FromStdCMYK(AValue: TStdCMYK);
    procedure FromLinearRGBA(AValue: TLinearRGBA);
    procedure FromXYZA(AValue: TXYZA);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
  end;
  
  {TGSBAPixelHelper}
  
  TGSBAPixelHelper = record helper{$IFDEF OBJ}(TGSBAPixelBasicHelper){$ENDIF} for TGSBAPixel
    class function New(const AHue,ASaturation,ABrightness,AAlpha:BGRAWord): TGSBAPixel;overload;static;
    class function New(const AHue,ASaturation,ABrightness:BGRAWord): TGSBAPixel;overload;static;
    class function Colorspace: TColorspaceAny; static;
    function ToStdRGBA: TStdRGBA;
    function ToAdobeRGBA: TAdobeRGBA;
    function ToStdHSLA: TStdHSLA;
    function ToStdHSVA: TStdHSVA;
    function ToStdCMYK: TStdCMYK;
    function ToLinearRGBA: TLinearRGBA;
    function ToXYZA: TXYZA;
    function ToLabA: TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromStdRGBA(AValue: TStdRGBA);
    procedure FromAdobeRGBA(AValue: TAdobeRGBA);
    procedure FromStdHSLA(AValue: TStdHSLA);
    procedure FromStdHSVA(AValue: TStdHSVA);
    procedure FromStdCMYK(AValue: TStdCMYK);
    procedure FromLinearRGBA(AValue: TLinearRGBA);
    procedure FromXYZA(AValue: TXYZA);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
  end;
  
  {TXYZAHelper}
  
  TXYZAHelper = record helper for TXYZA
    class function Colorspace: TColorspaceAny; static;
    function ToColor: TColor;
    function ToBGRAPixel: TBGRAPixel;
    function ToStdRGBA: TStdRGBA;
    function ToAdobeRGBA: TAdobeRGBA;
    function ToStdHSLA: TStdHSLA;
    function ToStdHSVA: TStdHSVA;
    function ToStdCMYK: TStdCMYK;
    function ToExpandedPixel: TExpandedPixel;
    function ToLinearRGBA: TLinearRGBA;
    function ToHSLAPixel: THSLAPixel;
    function ToGSBAPixel: TGSBAPixel;
    function ToLabA: TLabA;overload;
    function ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
    function ToLChA: TLChA;overload;
    function ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
    procedure FromColor(AValue: TColor);
    procedure FromBGRAPixel(AValue: TBGRAPixel);
    procedure FromStdRGBA(AValue: TStdRGBA);
    procedure FromAdobeRGBA(AValue: TAdobeRGBA);
    procedure FromStdHSLA(AValue: TStdHSLA);
    procedure FromStdHSVA(AValue: TStdHSVA);
    procedure FromStdCMYK(AValue: TStdCMYK);
    procedure FromExpandedPixel(AValue: TExpandedPixel);
    procedure FromLinearRGBA(AValue: TLinearRGBA);
    procedure FromHSLAPixel(AValue: THSLAPixel);
    procedure FromGSBAPixel(AValue: TGSBAPixel);
    procedure FromLabA(AValue: TLabA); overload;
    procedure FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA); overload;
    procedure FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
  end;
  
  {TLabAHelper}
  
  TLabAHelper = record helper for TLabA
    class function Colorspace: TColorspaceAny; static;
    function ToColor: TColor;overload;
    function ToColor(const AReferenceWhite: TXYZReferenceWhite): TColor;overload;
    function ToBGRAPixel: TBGRAPixel;overload;
    function ToBGRAPixel(const AReferenceWhite: TXYZReferenceWhite): TBGRAPixel;overload;
    function ToStdRGBA: TStdRGBA;overload;
    function ToStdRGBA(const AReferenceWhite: TXYZReferenceWhite): TStdRGBA;overload;
    function ToAdobeRGBA: TAdobeRGBA;overload;
    function ToAdobeRGBA(const AReferenceWhite: TXYZReferenceWhite): TAdobeRGBA;overload;
    function ToStdHSLA: TStdHSLA;overload;
    function ToStdHSLA(const AReferenceWhite: TXYZReferenceWhite): TStdHSLA;overload;
    function ToStdHSVA: TStdHSVA;overload;
    function ToStdHSVA(const AReferenceWhite: TXYZReferenceWhite): TStdHSVA;overload;
    function ToStdCMYK: TStdCMYK;overload;
    function ToStdCMYK(const AReferenceWhite: TXYZReferenceWhite): TStdCMYK;overload;
    function ToExpandedPixel: TExpandedPixel;overload;
    function ToExpandedPixel(const AReferenceWhite: TXYZReferenceWhite): TExpandedPixel;overload;
    function ToLinearRGBA: TLinearRGBA;overload;
    function ToLinearRGBA(const AReferenceWhite: TXYZReferenceWhite): TLinearRGBA;overload;
    function ToHSLAPixel: THSLAPixel;overload;
    function ToHSLAPixel(const AReferenceWhite: TXYZReferenceWhite): THSLAPixel;overload;
    function ToGSBAPixel: TGSBAPixel;overload;
    function ToGSBAPixel(const AReferenceWhite: TXYZReferenceWhite): TGSBAPixel;overload;
    function ToXYZA: TXYZA;overload;
    function ToXYZA(const AReferenceWhite: TXYZReferenceWhite): TXYZA;overload;
    function ToLChA: TLChA;
    procedure FromColor(AValue: TColor); overload;
    procedure FromColor(AValue: TColor; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromBGRAPixel(AValue: TBGRAPixel); overload;
    procedure FromBGRAPixel(AValue: TBGRAPixel; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromStdRGBA(AValue: TStdRGBA); overload;
    procedure FromStdRGBA(AValue: TStdRGBA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromAdobeRGBA(AValue: TAdobeRGBA); overload;
    procedure FromAdobeRGBA(AValue: TAdobeRGBA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromStdHSLA(AValue: TStdHSLA); overload;
    procedure FromStdHSLA(AValue: TStdHSLA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromStdHSVA(AValue: TStdHSVA); overload;
    procedure FromStdHSVA(AValue: TStdHSVA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromStdCMYK(AValue: TStdCMYK); overload;
    procedure FromStdCMYK(AValue: TStdCMYK; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromExpandedPixel(AValue: TExpandedPixel); overload;
    procedure FromExpandedPixel(AValue: TExpandedPixel; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLinearRGBA(AValue: TLinearRGBA); overload;
    procedure FromLinearRGBA(AValue: TLinearRGBA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromHSLAPixel(AValue: THSLAPixel); overload;
    procedure FromHSLAPixel(AValue: THSLAPixel; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromGSBAPixel(AValue: TGSBAPixel); overload;
    procedure FromGSBAPixel(AValue: TGSBAPixel; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromXYZA(AValue: TXYZA); overload;
    procedure FromXYZA(AValue: TXYZA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLChA(AValue: TLChA);
  end;
  
  {TLChAHelper}
  
  TLChAHelper = record helper for TLChA
    class function Colorspace: TColorspaceAny; static;
    function ToColor: TColor;overload;
    function ToColor(const AReferenceWhite: TXYZReferenceWhite): TColor;overload;
    function ToBGRAPixel: TBGRAPixel;overload;
    function ToBGRAPixel(const AReferenceWhite: TXYZReferenceWhite): TBGRAPixel;overload;
    function ToStdRGBA: TStdRGBA;overload;
    function ToStdRGBA(const AReferenceWhite: TXYZReferenceWhite): TStdRGBA;overload;
    function ToAdobeRGBA: TAdobeRGBA;overload;
    function ToAdobeRGBA(const AReferenceWhite: TXYZReferenceWhite): TAdobeRGBA;overload;
    function ToStdHSLA: TStdHSLA;overload;
    function ToStdHSLA(const AReferenceWhite: TXYZReferenceWhite): TStdHSLA;overload;
    function ToStdHSVA: TStdHSVA;overload;
    function ToStdHSVA(const AReferenceWhite: TXYZReferenceWhite): TStdHSVA;overload;
    function ToStdCMYK: TStdCMYK;overload;
    function ToStdCMYK(const AReferenceWhite: TXYZReferenceWhite): TStdCMYK;overload;
    function ToExpandedPixel: TExpandedPixel;overload;
    function ToExpandedPixel(const AReferenceWhite: TXYZReferenceWhite): TExpandedPixel;overload;
    function ToLinearRGBA: TLinearRGBA;overload;
    function ToLinearRGBA(const AReferenceWhite: TXYZReferenceWhite): TLinearRGBA;overload;
    function ToHSLAPixel: THSLAPixel;overload;
    function ToHSLAPixel(const AReferenceWhite: TXYZReferenceWhite): THSLAPixel;overload;
    function ToGSBAPixel: TGSBAPixel;overload;
    function ToGSBAPixel(const AReferenceWhite: TXYZReferenceWhite): TGSBAPixel;overload;
    function ToXYZA: TXYZA;overload;
    function ToXYZA(const AReferenceWhite: TXYZReferenceWhite): TXYZA;overload;
    function ToLabA: TLabA;
    procedure FromColor(AValue: TColor); overload;
    procedure FromColor(AValue: TColor; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromBGRAPixel(AValue: TBGRAPixel); overload;
    procedure FromBGRAPixel(AValue: TBGRAPixel; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromStdRGBA(AValue: TStdRGBA); overload;
    procedure FromStdRGBA(AValue: TStdRGBA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromAdobeRGBA(AValue: TAdobeRGBA); overload;
    procedure FromAdobeRGBA(AValue: TAdobeRGBA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromStdHSLA(AValue: TStdHSLA); overload;
    procedure FromStdHSLA(AValue: TStdHSLA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromStdHSVA(AValue: TStdHSVA); overload;
    procedure FromStdHSVA(AValue: TStdHSVA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromStdCMYK(AValue: TStdCMYK); overload;
    procedure FromStdCMYK(AValue: TStdCMYK; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromExpandedPixel(AValue: TExpandedPixel); overload;
    procedure FromExpandedPixel(AValue: TExpandedPixel; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLinearRGBA(AValue: TLinearRGBA); overload;
    procedure FromLinearRGBA(AValue: TLinearRGBA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromHSLAPixel(AValue: THSLAPixel); overload;
    procedure FromHSLAPixel(AValue: THSLAPixel; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromGSBAPixel(AValue: TGSBAPixel); overload;
    procedure FromGSBAPixel(AValue: TGSBAPixel; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromXYZA(AValue: TXYZA); overload;
    procedure FromXYZA(AValue: TXYZA; const AReferenceWhite: TXYZReferenceWhite); overload;
    procedure FromLabA(AValue: TLabA);
  end;
  
{$IFDEF OBJ}
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel)    : PStdRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel)    : PAdobeRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel)    : PStdHSLA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel)    : PStdHSVA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel)    : PStdCMYK;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel)    : PLinearRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel)    : PXYZA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel)    : PLabA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel)    : PLChA;
//
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PStdRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PAdobeRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PStdHSLA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PStdHSVA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PStdCMYK;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PLinearRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PXYZA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PLabA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PLChA;
//
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel)    : PStdRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel)    : PAdobeRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel)    : PStdHSLA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel)    : PStdHSVA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel)    : PStdCMYK;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel)    : PLinearRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel)    : PXYZA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel)    : PLabA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel)    : PLChA;
//
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel)    : PStdRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel)    : PAdobeRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel)    : PStdHSLA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel)    : PStdHSVA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel)    : PStdCMYK;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel)    : PLinearRGBA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel)    : PXYZA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel)    : PLabA;
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel)    : PLChA;
{$ENDIF}
{$ENDIF}
{$IFDEF INCLUDE_IMPLEMENTATION}
{$UNDEF INCLUDE_IMPLEMENTATION}

{Converters}

procedure ConvertColorArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := ColorToBGRA(TColor(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToStdRGBA(const AColor: TColor;const AAlpha: single=1): TStdRGBA;
begin Result := BGRAPixelToStdRGBA(ColorToBGRA(AColor));
  Result.alpha := AAlpha end;

procedure ConvertColorArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdRGBA(ADest^) := ColorToStdRGBA(TColor(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToAdobeRGBA(const AColor: TColor;const AAlpha: byte=255): TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ColorToBGRA(AColor)))));
  Result.alpha := AAlpha end;

procedure ConvertColorArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := ColorToAdobeRGBA(TColor(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToStdHSLA(const AColor: TColor;const AAlpha: single=1): TStdHSLA;
begin Result := StdRGBAToStdHSLA(BGRAPixelToStdRGBA(ColorToBGRA(AColor)));
  Result.alpha := AAlpha end;

procedure ConvertColorArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSLA(ADest^) := ColorToStdHSLA(TColor(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToStdHSVA(const AColor: TColor;const AAlpha: single=1): TStdHSVA;
begin Result := StdRGBAToStdHSVA(BGRAPixelToStdRGBA(ColorToBGRA(AColor)));
  Result.alpha := AAlpha end;

procedure ConvertColorArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSVA(ADest^) := ColorToStdHSVA(TColor(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToStdCMYK(const AColor: TColor): TStdCMYK;
begin Result := StdRGBAToStdCMYK(BGRAPixelToStdRGBA(ColorToBGRA(AColor))) end;

procedure ConvertColorArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdCMYK(ADest^) := ColorToStdCMYK(TColor(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToExpandedPixel(const AColor: TColor;const AAlpha: BGRAWord=65535): TExpandedPixel;
begin Result := GammaExpansion(ColorToBGRA(AColor));
  Result.alpha := AAlpha end;

procedure ConvertColorArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := ColorToExpandedPixel(TColor(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToLinearRGBA(const AColor: TColor;const AAlpha: single=1): TLinearRGBA;
begin Result := StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ColorToBGRA(AColor)));
  Result.alpha := AAlpha end;

procedure ConvertColorArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := ColorToLinearRGBA(TColor(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToHSLAPixel(const AColor: TColor;const AAlpha: BGRAWord=65535): THSLAPixel;
begin Result := BGRAToHSLA(ColorToBGRA(AColor));
  Result.alpha := AAlpha end;

procedure ConvertColorArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    THSLAPixel(ADest^) := ColorToHSLAPixel(TColor(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToGSBAPixel(const AColor: TColor;const AAlpha: BGRAWord=65535): TGSBAPixel;
begin Result := BGRAToGSBA(ColorToBGRA(AColor));
  Result.alpha := AAlpha end;

procedure ConvertColorArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := ColorToGSBAPixel(TColor(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToXYZA(const AColor: TColor;const AAlpha: single=1): TXYZA;
begin Result := LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ColorToBGRA(AColor))));
  Result.alpha := AAlpha end;

procedure ConvertColorArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TXYZA(ADest^) := ColorToXYZA(TColor(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToLabA(const AColor: TColor;const AAlpha: single=1): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ColorToBGRA(AColor)))));
  Result.alpha := AAlpha end;

function ColorToLabA(const AColor: TColor; const AReferenceWhite: TXYZReferenceWhite;const AAlpha: single=1): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ColorToBGRA(AColor)))),AReferenceWhite);
  Result.alpha := AAlpha end;

procedure ConvertColorArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := ColorToLabA(TColor(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ColorToLChA(const AColor: TColor;const AAlpha: single=1): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ColorToBGRA(AColor))))));
  Result.alpha := AAlpha end;

function ColorToLChA(const AColor: TColor; const AReferenceWhite: TXYZReferenceWhite;const AAlpha: single=1): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ColorToBGRA(AColor)))),AReferenceWhite));
  Result.alpha := AAlpha end;

procedure ConvertColorArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TColor); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := ColorToLChA(TColor(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertBGRAPixelArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TColor(ADest^) := BGRAToColor(TBGRAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertBGRAPixelArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdRGBA(ADest^) := BGRAPixelToStdRGBA(TBGRAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function BGRAPixelToAdobeRGBA(const ABGRAPixel: TBGRAPixel): TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ABGRAPixel)))) end;

procedure ConvertBGRAPixelArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := BGRAPixelToAdobeRGBA(TBGRAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function BGRAPixelToStdHSLA(const ABGRAPixel: TBGRAPixel): TStdHSLA;
begin Result := StdRGBAToStdHSLA(BGRAPixelToStdRGBA(ABGRAPixel)) end;

procedure ConvertBGRAPixelArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSLA(ADest^) := BGRAPixelToStdHSLA(TBGRAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function BGRAPixelToStdHSVA(const ABGRAPixel: TBGRAPixel): TStdHSVA;
begin Result := StdRGBAToStdHSVA(BGRAPixelToStdRGBA(ABGRAPixel)) end;

procedure ConvertBGRAPixelArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSVA(ADest^) := BGRAPixelToStdHSVA(TBGRAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function BGRAPixelToStdCMYK(const ABGRAPixel: TBGRAPixel): TStdCMYK;
begin Result := StdRGBAToStdCMYK(BGRAPixelToStdRGBA(ABGRAPixel)) end;

procedure ConvertBGRAPixelArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdCMYK(ADest^) := BGRAPixelToStdCMYK(TBGRAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertBGRAPixelArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := GammaExpansion(TBGRAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function BGRAPixelToLinearRGBA(const ABGRAPixel: TBGRAPixel): TLinearRGBA;
begin Result := StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ABGRAPixel)) end;

procedure ConvertBGRAPixelArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := BGRAPixelToLinearRGBA(TBGRAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertBGRAPixelArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    THSLAPixel(ADest^) := BGRAToHSLA(TBGRAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertBGRAPixelArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := BGRAToGSBA(TBGRAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function BGRAPixelToXYZA(const ABGRAPixel: TBGRAPixel): TXYZA;
begin Result := LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ABGRAPixel))) end;

procedure ConvertBGRAPixelArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TXYZA(ADest^) := BGRAPixelToXYZA(TBGRAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function BGRAPixelToLabA(const ABGRAPixel: TBGRAPixel): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ABGRAPixel)))) end;

function BGRAPixelToLabA(const ABGRAPixel: TBGRAPixel; const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ABGRAPixel))),AReferenceWhite) end;

procedure ConvertBGRAPixelArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := BGRAPixelToLabA(TBGRAPixel(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function BGRAPixelToLChA(const ABGRAPixel: TBGRAPixel): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ABGRAPixel))))) end;

function BGRAPixelToLChA(const ABGRAPixel: TBGRAPixel; const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(BGRAPixelToStdRGBA(ABGRAPixel))),AReferenceWhite)) end;

procedure ConvertBGRAPixelArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TBGRAPixel); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := BGRAPixelToLChA(TBGRAPixel(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdRGBAToColor(const AStdRGBA: TStdRGBA): TColor;
begin Result := BGRAToColor(StdRGBAToBGRAPixel(AStdRGBA)) end;

procedure ConvertStdRGBAArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TColor(ADest^) := StdRGBAToColor(TStdRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertStdRGBAArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := StdRGBAToBGRAPixel(TStdRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdRGBAToAdobeRGBA(const AStdRGBA: TStdRGBA): TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(AStdRGBA))) end;

procedure ConvertStdRGBAArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := StdRGBAToAdobeRGBA(TStdRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertStdRGBAArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSLA(ADest^) := StdRGBAToStdHSLA(TStdRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertStdRGBAArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSVA(ADest^) := StdRGBAToStdHSVA(TStdRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertStdRGBAArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdCMYK(ADest^) := StdRGBAToStdCMYK(TStdRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdRGBAToExpandedPixel(const AStdRGBA: TStdRGBA): TExpandedPixel;
begin Result := GammaExpansion(StdRGBAToBGRAPixel(AStdRGBA)) end;

procedure ConvertStdRGBAArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := StdRGBAToExpandedPixel(TStdRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertStdRGBAArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := StdRGBAToLinearRGBA(TStdRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdRGBAToHSLAPixel(const AStdRGBA: TStdRGBA): THSLAPixel;
begin Result := BGRAToHSLA(StdRGBAToBGRAPixel(AStdRGBA)) end;

procedure ConvertStdRGBAArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    THSLAPixel(ADest^) := StdRGBAToHSLAPixel(TStdRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdRGBAToGSBAPixel(const AStdRGBA: TStdRGBA): TGSBAPixel;
begin Result := BGRAToGSBA(StdRGBAToBGRAPixel(AStdRGBA)) end;

procedure ConvertStdRGBAArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := StdRGBAToGSBAPixel(TStdRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdRGBAToXYZA(const AStdRGBA: TStdRGBA): TXYZA;
begin Result := LinearRGBAToXYZA(StdRGBAToLinearRGBA(AStdRGBA)) end;

procedure ConvertStdRGBAArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TXYZA(ADest^) := StdRGBAToXYZA(TStdRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdRGBAToLabA(const AStdRGBA: TStdRGBA): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(AStdRGBA))) end;

function StdRGBAToLabA(const AStdRGBA: TStdRGBA; const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(AStdRGBA)),AReferenceWhite) end;

procedure ConvertStdRGBAArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := StdRGBAToLabA(TStdRGBA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdRGBAToLChA(const AStdRGBA: TStdRGBA): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(AStdRGBA)))) end;

function StdRGBAToLChA(const AStdRGBA: TStdRGBA; const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(AStdRGBA)),AReferenceWhite)) end;

procedure ConvertStdRGBAArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdRGBA); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := StdRGBAToLChA(TStdRGBA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToColor(const AAdobeRGBA: TAdobeRGBA): TColor;
begin Result := BGRAToColor(StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(AdobeRGBAToXYZA(AAdobeRGBA))))) end;

procedure ConvertAdobeRGBAArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TColor(ADest^) := AdobeRGBAToColor(TAdobeRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToBGRAPixel(const AAdobeRGBA: TAdobeRGBA): TBGRAPixel;
begin Result := StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(AdobeRGBAToXYZA(AAdobeRGBA)))) end;

procedure ConvertAdobeRGBAArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := AdobeRGBAToBGRAPixel(TAdobeRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToStdRGBA(const AAdobeRGBA: TAdobeRGBA): TStdRGBA;
begin Result := LinearRGBAToStdRGBA(XYZAToLinearRGBA(AdobeRGBAToXYZA(AAdobeRGBA))) end;

procedure ConvertAdobeRGBAArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdRGBA(ADest^) := AdobeRGBAToStdRGBA(TAdobeRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToStdHSLA(const AAdobeRGBA: TAdobeRGBA): TStdHSLA;
begin Result := StdRGBAToStdHSLA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(AdobeRGBAToXYZA(AAdobeRGBA)))) end;

procedure ConvertAdobeRGBAArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSLA(ADest^) := AdobeRGBAToStdHSLA(TAdobeRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToStdHSVA(const AAdobeRGBA: TAdobeRGBA): TStdHSVA;
begin Result := StdRGBAToStdHSVA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(AdobeRGBAToXYZA(AAdobeRGBA)))) end;

procedure ConvertAdobeRGBAArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSVA(ADest^) := AdobeRGBAToStdHSVA(TAdobeRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToStdCMYK(const AAdobeRGBA: TAdobeRGBA): TStdCMYK;
begin Result := StdRGBAToStdCMYK(LinearRGBAToStdRGBA(XYZAToLinearRGBA(AdobeRGBAToXYZA(AAdobeRGBA)))) end;

procedure ConvertAdobeRGBAArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdCMYK(ADest^) := AdobeRGBAToStdCMYK(TAdobeRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToExpandedPixel(const AAdobeRGBA: TAdobeRGBA): TExpandedPixel;
begin Result := LinearRGBAToExpandedPixel(XYZAToLinearRGBA(AdobeRGBAToXYZA(AAdobeRGBA))) end;

procedure ConvertAdobeRGBAArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := AdobeRGBAToExpandedPixel(TAdobeRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToLinearRGBA(const AAdobeRGBA: TAdobeRGBA): TLinearRGBA;
begin Result := XYZAToLinearRGBA(AdobeRGBAToXYZA(AAdobeRGBA)) end;

procedure ConvertAdobeRGBAArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := AdobeRGBAToLinearRGBA(TAdobeRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToHSLAPixel(const AAdobeRGBA: TAdobeRGBA): THSLAPixel;
begin Result := ExpandedToHSLA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(AdobeRGBAToXYZA(AAdobeRGBA)))) end;

procedure ConvertAdobeRGBAArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    THSLAPixel(ADest^) := AdobeRGBAToHSLAPixel(TAdobeRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToGSBAPixel(const AAdobeRGBA: TAdobeRGBA): TGSBAPixel;
begin Result := ExpandedToGSBA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(AdobeRGBAToXYZA(AAdobeRGBA)))) end;

procedure ConvertAdobeRGBAArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := AdobeRGBAToGSBAPixel(TAdobeRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertAdobeRGBAArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TXYZA(ADest^) := AdobeRGBAToXYZA(TAdobeRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToLabA(const AAdobeRGBA: TAdobeRGBA): TLabA;overload;
begin Result := XYZAToLabA(AdobeRGBAToXYZA(AAdobeRGBA)) end;

function AdobeRGBAToLabA(const AAdobeRGBA: TAdobeRGBA; const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
begin Result := XYZAToLabA(AdobeRGBAToXYZA(AAdobeRGBA),AReferenceWhite) end;

procedure ConvertAdobeRGBAArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := AdobeRGBAToLabA(TAdobeRGBA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function AdobeRGBAToLChA(const AAdobeRGBA: TAdobeRGBA): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(AdobeRGBAToXYZA(AAdobeRGBA))) end;

function AdobeRGBAToLChA(const AAdobeRGBA: TAdobeRGBA; const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(AdobeRGBAToXYZA(AAdobeRGBA),AReferenceWhite)) end;

procedure ConvertAdobeRGBAArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TAdobeRGBA); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := AdobeRGBAToLChA(TAdobeRGBA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSLAToColor(const AStdHSLA: TStdHSLA): TColor;
begin Result := BGRAToColor(StdRGBAToBGRAPixel(StdHSLAToStdRGBA(AStdHSLA))) end;

procedure ConvertStdHSLAArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TColor(ADest^) := StdHSLAToColor(TStdHSLA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSLAToBGRAPixel(const AStdHSLA: TStdHSLA): TBGRAPixel;
begin Result := StdRGBAToBGRAPixel(StdHSLAToStdRGBA(AStdHSLA)) end;

procedure ConvertStdHSLAArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := StdHSLAToBGRAPixel(TStdHSLA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertStdHSLAArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdRGBA(ADest^) := StdHSLAToStdRGBA(TStdHSLA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSLAToAdobeRGBA(const AStdHSLA: TStdHSLA): TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSLAToStdRGBA(AStdHSLA)))) end;

procedure ConvertStdHSLAArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := StdHSLAToAdobeRGBA(TStdHSLA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertStdHSLAArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSVA(ADest^) := StdHSLAToStdHSVA(TStdHSLA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSLAToStdCMYK(const AStdHSLA: TStdHSLA): TStdCMYK;
begin Result := StdRGBAToStdCMYK(StdHSLAToStdRGBA(AStdHSLA)) end;

procedure ConvertStdHSLAArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdCMYK(ADest^) := StdHSLAToStdCMYK(TStdHSLA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSLAToExpandedPixel(const AStdHSLA: TStdHSLA): TExpandedPixel;
begin Result := GammaExpansion(StdRGBAToBGRAPixel(StdHSLAToStdRGBA(AStdHSLA))) end;

procedure ConvertStdHSLAArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := StdHSLAToExpandedPixel(TStdHSLA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSLAToLinearRGBA(const AStdHSLA: TStdHSLA): TLinearRGBA;
begin Result := StdRGBAToLinearRGBA(StdHSLAToStdRGBA(AStdHSLA)) end;

procedure ConvertStdHSLAArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := StdHSLAToLinearRGBA(TStdHSLA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSLAToHSLAPixel(const AStdHSLA: TStdHSLA): THSLAPixel;
begin Result := BGRAToHSLA(StdRGBAToBGRAPixel(StdHSLAToStdRGBA(AStdHSLA))) end;

procedure ConvertStdHSLAArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    THSLAPixel(ADest^) := StdHSLAToHSLAPixel(TStdHSLA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSLAToGSBAPixel(const AStdHSLA: TStdHSLA): TGSBAPixel;
begin Result := BGRAToGSBA(StdRGBAToBGRAPixel(StdHSLAToStdRGBA(AStdHSLA))) end;

procedure ConvertStdHSLAArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := StdHSLAToGSBAPixel(TStdHSLA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSLAToXYZA(const AStdHSLA: TStdHSLA): TXYZA;
begin Result := LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSLAToStdRGBA(AStdHSLA))) end;

procedure ConvertStdHSLAArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TXYZA(ADest^) := StdHSLAToXYZA(TStdHSLA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSLAToLabA(const AStdHSLA: TStdHSLA): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSLAToStdRGBA(AStdHSLA)))) end;

function StdHSLAToLabA(const AStdHSLA: TStdHSLA; const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSLAToStdRGBA(AStdHSLA))),AReferenceWhite) end;

procedure ConvertStdHSLAArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := StdHSLAToLabA(TStdHSLA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSLAToLChA(const AStdHSLA: TStdHSLA): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSLAToStdRGBA(AStdHSLA))))) end;

function StdHSLAToLChA(const AStdHSLA: TStdHSLA; const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSLAToStdRGBA(AStdHSLA))),AReferenceWhite)) end;

procedure ConvertStdHSLAArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSLA); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := StdHSLAToLChA(TStdHSLA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSVAToColor(const AStdHSVA: TStdHSVA): TColor;
begin Result := BGRAToColor(StdRGBAToBGRAPixel(StdHSVAToStdRGBA(AStdHSVA))) end;

procedure ConvertStdHSVAArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TColor(ADest^) := StdHSVAToColor(TStdHSVA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSVAToBGRAPixel(const AStdHSVA: TStdHSVA): TBGRAPixel;
begin Result := StdRGBAToBGRAPixel(StdHSVAToStdRGBA(AStdHSVA)) end;

procedure ConvertStdHSVAArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := StdHSVAToBGRAPixel(TStdHSVA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertStdHSVAArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdRGBA(ADest^) := StdHSVAToStdRGBA(TStdHSVA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSVAToAdobeRGBA(const AStdHSVA: TStdHSVA): TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSVAToStdRGBA(AStdHSVA)))) end;

procedure ConvertStdHSVAArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := StdHSVAToAdobeRGBA(TStdHSVA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertStdHSVAArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSLA(ADest^) := StdHSVAToStdHSLA(TStdHSVA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSVAToStdCMYK(const AStdHSVA: TStdHSVA): TStdCMYK;
begin Result := StdRGBAToStdCMYK(StdHSVAToStdRGBA(AStdHSVA)) end;

procedure ConvertStdHSVAArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdCMYK(ADest^) := StdHSVAToStdCMYK(TStdHSVA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSVAToExpandedPixel(const AStdHSVA: TStdHSVA): TExpandedPixel;
begin Result := GammaExpansion(StdRGBAToBGRAPixel(StdHSVAToStdRGBA(AStdHSVA))) end;

procedure ConvertStdHSVAArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := StdHSVAToExpandedPixel(TStdHSVA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSVAToLinearRGBA(const AStdHSVA: TStdHSVA): TLinearRGBA;
begin Result := StdRGBAToLinearRGBA(StdHSVAToStdRGBA(AStdHSVA)) end;

procedure ConvertStdHSVAArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := StdHSVAToLinearRGBA(TStdHSVA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSVAToHSLAPixel(const AStdHSVA: TStdHSVA): THSLAPixel;
begin Result := BGRAToHSLA(StdRGBAToBGRAPixel(StdHSVAToStdRGBA(AStdHSVA))) end;

procedure ConvertStdHSVAArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    THSLAPixel(ADest^) := StdHSVAToHSLAPixel(TStdHSVA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSVAToGSBAPixel(const AStdHSVA: TStdHSVA): TGSBAPixel;
begin Result := BGRAToGSBA(StdRGBAToBGRAPixel(StdHSVAToStdRGBA(AStdHSVA))) end;

procedure ConvertStdHSVAArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := StdHSVAToGSBAPixel(TStdHSVA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSVAToXYZA(const AStdHSVA: TStdHSVA): TXYZA;
begin Result := LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSVAToStdRGBA(AStdHSVA))) end;

procedure ConvertStdHSVAArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TXYZA(ADest^) := StdHSVAToXYZA(TStdHSVA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSVAToLabA(const AStdHSVA: TStdHSVA): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSVAToStdRGBA(AStdHSVA)))) end;

function StdHSVAToLabA(const AStdHSVA: TStdHSVA; const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSVAToStdRGBA(AStdHSVA))),AReferenceWhite) end;

procedure ConvertStdHSVAArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := StdHSVAToLabA(TStdHSVA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdHSVAToLChA(const AStdHSVA: TStdHSVA): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSVAToStdRGBA(AStdHSVA))))) end;

function StdHSVAToLChA(const AStdHSVA: TStdHSVA; const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdHSVAToStdRGBA(AStdHSVA))),AReferenceWhite)) end;

procedure ConvertStdHSVAArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdHSVA); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := StdHSVAToLChA(TStdHSVA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToColor(const AStdCMYK: TStdCMYK): TColor;
begin Result := BGRAToColor(StdRGBAToBGRAPixel(StdCMYKToStdRGBA(AStdCMYK))) end;

procedure ConvertStdCMYKArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TColor(ADest^) := StdCMYKToColor(TStdCMYK(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToBGRAPixel(const AStdCMYK: TStdCMYK;const AAlpha: byte=255): TBGRAPixel;
begin Result := StdRGBAToBGRAPixel(StdCMYKToStdRGBA(AStdCMYK));
  Result.alpha := AAlpha end;

procedure ConvertStdCMYKArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := StdCMYKToBGRAPixel(TStdCMYK(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertStdCMYKArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdRGBA(ADest^) := StdCMYKToStdRGBA(TStdCMYK(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToAdobeRGBA(const AStdCMYK: TStdCMYK;const AAlpha: byte=255): TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdCMYKToStdRGBA(AStdCMYK))));
  Result.alpha := AAlpha end;

procedure ConvertStdCMYKArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := StdCMYKToAdobeRGBA(TStdCMYK(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToStdHSLA(const AStdCMYK: TStdCMYK;const AAlpha: single=1): TStdHSLA;
begin Result := StdRGBAToStdHSLA(StdCMYKToStdRGBA(AStdCMYK));
  Result.alpha := AAlpha end;

procedure ConvertStdCMYKArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSLA(ADest^) := StdCMYKToStdHSLA(TStdCMYK(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToStdHSVA(const AStdCMYK: TStdCMYK;const AAlpha: single=1): TStdHSVA;
begin Result := StdRGBAToStdHSVA(StdCMYKToStdRGBA(AStdCMYK));
  Result.alpha := AAlpha end;

procedure ConvertStdCMYKArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSVA(ADest^) := StdCMYKToStdHSVA(TStdCMYK(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToExpandedPixel(const AStdCMYK: TStdCMYK;const AAlpha: BGRAWord=65535): TExpandedPixel;
begin Result := GammaExpansion(StdRGBAToBGRAPixel(StdCMYKToStdRGBA(AStdCMYK)));
  Result.alpha := AAlpha end;

procedure ConvertStdCMYKArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := StdCMYKToExpandedPixel(TStdCMYK(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToLinearRGBA(const AStdCMYK: TStdCMYK;const AAlpha: single=1): TLinearRGBA;
begin Result := StdRGBAToLinearRGBA(StdCMYKToStdRGBA(AStdCMYK));
  Result.alpha := AAlpha end;

procedure ConvertStdCMYKArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := StdCMYKToLinearRGBA(TStdCMYK(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToHSLAPixel(const AStdCMYK: TStdCMYK;const AAlpha: BGRAWord=65535): THSLAPixel;
begin Result := BGRAToHSLA(StdRGBAToBGRAPixel(StdCMYKToStdRGBA(AStdCMYK)));
  Result.alpha := AAlpha end;

procedure ConvertStdCMYKArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    THSLAPixel(ADest^) := StdCMYKToHSLAPixel(TStdCMYK(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToGSBAPixel(const AStdCMYK: TStdCMYK;const AAlpha: BGRAWord=65535): TGSBAPixel;
begin Result := BGRAToGSBA(StdRGBAToBGRAPixel(StdCMYKToStdRGBA(AStdCMYK)));
  Result.alpha := AAlpha end;

procedure ConvertStdCMYKArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := StdCMYKToGSBAPixel(TStdCMYK(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToXYZA(const AStdCMYK: TStdCMYK;const AAlpha: single=1): TXYZA;
begin Result := LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdCMYKToStdRGBA(AStdCMYK)));
  Result.alpha := AAlpha end;

procedure ConvertStdCMYKArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TXYZA(ADest^) := StdCMYKToXYZA(TStdCMYK(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToLabA(const AStdCMYK: TStdCMYK;const AAlpha: single=1): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdCMYKToStdRGBA(AStdCMYK))));
  Result.alpha := AAlpha end;

function StdCMYKToLabA(const AStdCMYK: TStdCMYK; const AReferenceWhite: TXYZReferenceWhite;const AAlpha: single=1): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdCMYKToStdRGBA(AStdCMYK))),AReferenceWhite);
  Result.alpha := AAlpha end;

procedure ConvertStdCMYKArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := StdCMYKToLabA(TStdCMYK(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function StdCMYKToLChA(const AStdCMYK: TStdCMYK;const AAlpha: single=1): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdCMYKToStdRGBA(AStdCMYK)))));
  Result.alpha := AAlpha end;

function StdCMYKToLChA(const AStdCMYK: TStdCMYK; const AReferenceWhite: TXYZReferenceWhite;const AAlpha: single=1): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(StdRGBAToLinearRGBA(StdCMYKToStdRGBA(AStdCMYK))),AReferenceWhite));
  Result.alpha := AAlpha end;

procedure ConvertStdCMYKArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TStdCMYK); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := StdCMYKToLChA(TStdCMYK(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ExpandedPixelToColor(const AExpandedPixel: TExpandedPixel): TColor;
begin Result := BGRAToColor(GammaCompression(AExpandedPixel)) end;

procedure ConvertExpandedPixelArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TColor(ADest^) := ExpandedPixelToColor(TExpandedPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertExpandedPixelArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := GammaCompression(TExpandedPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ExpandedPixelToStdRGBA(const AExpandedPixel: TExpandedPixel): TStdRGBA;
begin Result := BGRAPixelToStdRGBA(GammaCompression(AExpandedPixel)) end;

procedure ConvertExpandedPixelArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdRGBA(ADest^) := ExpandedPixelToStdRGBA(TExpandedPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ExpandedPixelToAdobeRGBA(const AExpandedPixel: TExpandedPixel): TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(AExpandedPixel))) end;

procedure ConvertExpandedPixelArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := ExpandedPixelToAdobeRGBA(TExpandedPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ExpandedPixelToStdHSLA(const AExpandedPixel: TExpandedPixel): TStdHSLA;
begin Result := StdRGBAToStdHSLA(LinearRGBAToStdRGBA(ExpandedPixelToLinearRGBA(AExpandedPixel))) end;

procedure ConvertExpandedPixelArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSLA(ADest^) := ExpandedPixelToStdHSLA(TExpandedPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ExpandedPixelToStdHSVA(const AExpandedPixel: TExpandedPixel): TStdHSVA;
begin Result := StdRGBAToStdHSVA(LinearRGBAToStdRGBA(ExpandedPixelToLinearRGBA(AExpandedPixel))) end;

procedure ConvertExpandedPixelArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSVA(ADest^) := ExpandedPixelToStdHSVA(TExpandedPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ExpandedPixelToStdCMYK(const AExpandedPixel: TExpandedPixel): TStdCMYK;
begin Result := StdRGBAToStdCMYK(LinearRGBAToStdRGBA(ExpandedPixelToLinearRGBA(AExpandedPixel))) end;

procedure ConvertExpandedPixelArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdCMYK(ADest^) := ExpandedPixelToStdCMYK(TExpandedPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertExpandedPixelArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := ExpandedPixelToLinearRGBA(TExpandedPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertExpandedPixelArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    THSLAPixel(ADest^) := ExpandedToHSLA(TExpandedPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertExpandedPixelArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := ExpandedToGSBA(TExpandedPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ExpandedPixelToXYZA(const AExpandedPixel: TExpandedPixel): TXYZA;
begin Result := LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(AExpandedPixel)) end;

procedure ConvertExpandedPixelArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TXYZA(ADest^) := ExpandedPixelToXYZA(TExpandedPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ExpandedPixelToLabA(const AExpandedPixel: TExpandedPixel): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(AExpandedPixel))) end;

function ExpandedPixelToLabA(const AExpandedPixel: TExpandedPixel; const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(AExpandedPixel)),AReferenceWhite) end;

procedure ConvertExpandedPixelArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := ExpandedPixelToLabA(TExpandedPixel(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function ExpandedPixelToLChA(const AExpandedPixel: TExpandedPixel): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(AExpandedPixel)))) end;

function ExpandedPixelToLChA(const AExpandedPixel: TExpandedPixel; const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(AExpandedPixel)),AReferenceWhite)) end;

procedure ConvertExpandedPixelArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TExpandedPixel); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := ExpandedPixelToLChA(TExpandedPixel(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LinearRGBAToColor(const ALinearRGBA: TLinearRGBA): TColor;
begin Result := BGRAToColor(StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(ALinearRGBA))) end;

procedure ConvertLinearRGBAArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TColor(ADest^) := LinearRGBAToColor(TLinearRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LinearRGBAToBGRAPixel(const ALinearRGBA: TLinearRGBA): TBGRAPixel;
begin Result := StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(ALinearRGBA)) end;

procedure ConvertLinearRGBAArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := LinearRGBAToBGRAPixel(TLinearRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertLinearRGBAArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdRGBA(ADest^) := LinearRGBAToStdRGBA(TLinearRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LinearRGBAToAdobeRGBA(const ALinearRGBA: TLinearRGBA): TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(LinearRGBAToXYZA(ALinearRGBA)) end;

procedure ConvertLinearRGBAArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := LinearRGBAToAdobeRGBA(TLinearRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LinearRGBAToStdHSLA(const ALinearRGBA: TLinearRGBA): TStdHSLA;
begin Result := StdRGBAToStdHSLA(LinearRGBAToStdRGBA(ALinearRGBA)) end;

procedure ConvertLinearRGBAArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSLA(ADest^) := LinearRGBAToStdHSLA(TLinearRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LinearRGBAToStdHSVA(const ALinearRGBA: TLinearRGBA): TStdHSVA;
begin Result := StdRGBAToStdHSVA(LinearRGBAToStdRGBA(ALinearRGBA)) end;

procedure ConvertLinearRGBAArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSVA(ADest^) := LinearRGBAToStdHSVA(TLinearRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LinearRGBAToStdCMYK(const ALinearRGBA: TLinearRGBA): TStdCMYK;
begin Result := StdRGBAToStdCMYK(LinearRGBAToStdRGBA(ALinearRGBA)) end;

procedure ConvertLinearRGBAArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdCMYK(ADest^) := LinearRGBAToStdCMYK(TLinearRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertLinearRGBAArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := LinearRGBAToExpandedPixel(TLinearRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LinearRGBAToHSLAPixel(const ALinearRGBA: TLinearRGBA): THSLAPixel;
begin Result := ExpandedToHSLA(LinearRGBAToExpandedPixel(ALinearRGBA)) end;

procedure ConvertLinearRGBAArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    THSLAPixel(ADest^) := LinearRGBAToHSLAPixel(TLinearRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LinearRGBAToGSBAPixel(const ALinearRGBA: TLinearRGBA): TGSBAPixel;
begin Result := ExpandedToGSBA(LinearRGBAToExpandedPixel(ALinearRGBA)) end;

procedure ConvertLinearRGBAArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := LinearRGBAToGSBAPixel(TLinearRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertLinearRGBAArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TXYZA(ADest^) := LinearRGBAToXYZA(TLinearRGBA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LinearRGBAToLabA(const ALinearRGBA: TLinearRGBA): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(ALinearRGBA)) end;

function LinearRGBAToLabA(const ALinearRGBA: TLinearRGBA; const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(ALinearRGBA),AReferenceWhite) end;

procedure ConvertLinearRGBAArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := LinearRGBAToLabA(TLinearRGBA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LinearRGBAToLChA(const ALinearRGBA: TLinearRGBA): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(ALinearRGBA))) end;

function LinearRGBAToLChA(const ALinearRGBA: TLinearRGBA; const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(ALinearRGBA),AReferenceWhite)) end;

procedure ConvertLinearRGBAArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLinearRGBA); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := LinearRGBAToLChA(TLinearRGBA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function HSLAPixelToColor(const AHSLAPixel: THSLAPixel): TColor;
begin Result := BGRAToColor(HSLAToBGRA(AHSLAPixel)) end;

procedure ConvertHSLAPixelArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TColor(ADest^) := HSLAPixelToColor(THSLAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertHSLAPixelArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := HSLAToBGRA(THSLAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function HSLAPixelToStdRGBA(const AHSLAPixel: THSLAPixel): TStdRGBA;
begin Result := BGRAPixelToStdRGBA(HSLAToBGRA(AHSLAPixel)) end;

procedure ConvertHSLAPixelArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdRGBA(ADest^) := HSLAPixelToStdRGBA(THSLAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function HSLAPixelToAdobeRGBA(const AHSLAPixel: THSLAPixel): TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(HSLAToExpanded(AHSLAPixel)))) end;

procedure ConvertHSLAPixelArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := HSLAPixelToAdobeRGBA(THSLAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function HSLAPixelToStdHSLA(const AHSLAPixel: THSLAPixel): TStdHSLA;
begin Result := StdRGBAToStdHSLA(BGRAPixelToStdRGBA(HSLAToBGRA(AHSLAPixel))) end;

procedure ConvertHSLAPixelArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSLA(ADest^) := HSLAPixelToStdHSLA(THSLAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function HSLAPixelToStdHSVA(const AHSLAPixel: THSLAPixel): TStdHSVA;
begin Result := StdRGBAToStdHSVA(BGRAPixelToStdRGBA(HSLAToBGRA(AHSLAPixel))) end;

procedure ConvertHSLAPixelArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSVA(ADest^) := HSLAPixelToStdHSVA(THSLAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function HSLAPixelToStdCMYK(const AHSLAPixel: THSLAPixel): TStdCMYK;
begin Result := StdRGBAToStdCMYK(BGRAPixelToStdRGBA(HSLAToBGRA(AHSLAPixel))) end;

procedure ConvertHSLAPixelArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdCMYK(ADest^) := HSLAPixelToStdCMYK(THSLAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertHSLAPixelArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := HSLAToExpanded(THSLAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function HSLAPixelToLinearRGBA(const AHSLAPixel: THSLAPixel): TLinearRGBA;
begin Result := ExpandedPixelToLinearRGBA(HSLAToExpanded(AHSLAPixel)) end;

procedure ConvertHSLAPixelArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := HSLAPixelToLinearRGBA(THSLAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertHSLAPixelArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := HSLAToGSBA(THSLAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function HSLAPixelToXYZA(const AHSLAPixel: THSLAPixel): TXYZA;
begin Result := LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(HSLAToExpanded(AHSLAPixel))) end;

procedure ConvertHSLAPixelArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TXYZA(ADest^) := HSLAPixelToXYZA(THSLAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function HSLAPixelToLabA(const AHSLAPixel: THSLAPixel): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(HSLAToExpanded(AHSLAPixel)))) end;

function HSLAPixelToLabA(const AHSLAPixel: THSLAPixel; const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(HSLAToExpanded(AHSLAPixel))),AReferenceWhite) end;

procedure ConvertHSLAPixelArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := HSLAPixelToLabA(THSLAPixel(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function HSLAPixelToLChA(const AHSLAPixel: THSLAPixel): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(HSLAToExpanded(AHSLAPixel))))) end;

function HSLAPixelToLChA(const AHSLAPixel: THSLAPixel; const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(HSLAToExpanded(AHSLAPixel))),AReferenceWhite)) end;

procedure ConvertHSLAPixelArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(THSLAPixel); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := HSLAPixelToLChA(THSLAPixel(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function GSBAPixelToColor(const AGSBAPixel: TGSBAPixel): TColor;
begin Result := BGRAToColor(GSBAToBGRA(AGSBAPixel)) end;

procedure ConvertGSBAPixelArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TColor(ADest^) := GSBAPixelToColor(TGSBAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertGSBAPixelArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := GSBAToBGRA(TGSBAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function GSBAPixelToStdRGBA(const AGSBAPixel: TGSBAPixel): TStdRGBA;
begin Result := BGRAPixelToStdRGBA(GSBAToBGRA(AGSBAPixel)) end;

procedure ConvertGSBAPixelArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdRGBA(ADest^) := GSBAPixelToStdRGBA(TGSBAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function GSBAPixelToAdobeRGBA(const AGSBAPixel: TGSBAPixel): TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(GSBAToExpanded(AGSBAPixel)))) end;

procedure ConvertGSBAPixelArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := GSBAPixelToAdobeRGBA(TGSBAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function GSBAPixelToStdHSLA(const AGSBAPixel: TGSBAPixel): TStdHSLA;
begin Result := StdRGBAToStdHSLA(BGRAPixelToStdRGBA(GSBAToBGRA(AGSBAPixel))) end;

procedure ConvertGSBAPixelArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSLA(ADest^) := GSBAPixelToStdHSLA(TGSBAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function GSBAPixelToStdHSVA(const AGSBAPixel: TGSBAPixel): TStdHSVA;
begin Result := StdRGBAToStdHSVA(BGRAPixelToStdRGBA(GSBAToBGRA(AGSBAPixel))) end;

procedure ConvertGSBAPixelArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSVA(ADest^) := GSBAPixelToStdHSVA(TGSBAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function GSBAPixelToStdCMYK(const AGSBAPixel: TGSBAPixel): TStdCMYK;
begin Result := StdRGBAToStdCMYK(BGRAPixelToStdRGBA(GSBAToBGRA(AGSBAPixel))) end;

procedure ConvertGSBAPixelArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdCMYK(ADest^) := GSBAPixelToStdCMYK(TGSBAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertGSBAPixelArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := GSBAToExpanded(TGSBAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function GSBAPixelToLinearRGBA(const AGSBAPixel: TGSBAPixel): TLinearRGBA;
begin Result := ExpandedPixelToLinearRGBA(GSBAToExpanded(AGSBAPixel)) end;

procedure ConvertGSBAPixelArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := GSBAPixelToLinearRGBA(TGSBAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertGSBAPixelArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    THSLAPixel(ADest^) := GSBAToHSLA(TGSBAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function GSBAPixelToXYZA(const AGSBAPixel: TGSBAPixel): TXYZA;
begin Result := LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(GSBAToExpanded(AGSBAPixel))) end;

procedure ConvertGSBAPixelArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TXYZA(ADest^) := GSBAPixelToXYZA(TGSBAPixel(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function GSBAPixelToLabA(const AGSBAPixel: TGSBAPixel): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(GSBAToExpanded(AGSBAPixel)))) end;

function GSBAPixelToLabA(const AGSBAPixel: TGSBAPixel; const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
begin Result := XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(GSBAToExpanded(AGSBAPixel))),AReferenceWhite) end;

procedure ConvertGSBAPixelArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := GSBAPixelToLabA(TGSBAPixel(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function GSBAPixelToLChA(const AGSBAPixel: TGSBAPixel): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(GSBAToExpanded(AGSBAPixel))))) end;

function GSBAPixelToLChA(const AGSBAPixel: TGSBAPixel; const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(LinearRGBAToXYZA(ExpandedPixelToLinearRGBA(GSBAToExpanded(AGSBAPixel))),AReferenceWhite)) end;

procedure ConvertGSBAPixelArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TGSBAPixel); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := GSBAPixelToLChA(TGSBAPixel(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function XYZAToColor(const AXYZA: TXYZA): TColor;
begin Result := BGRAToColor(StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(AXYZA)))) end;

procedure ConvertXYZAArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TColor(ADest^) := XYZAToColor(TXYZA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function XYZAToBGRAPixel(const AXYZA: TXYZA): TBGRAPixel;
begin Result := StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(AXYZA))) end;

procedure ConvertXYZAArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := XYZAToBGRAPixel(TXYZA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function XYZAToStdRGBA(const AXYZA: TXYZA): TStdRGBA;
begin Result := LinearRGBAToStdRGBA(XYZAToLinearRGBA(AXYZA)) end;

procedure ConvertXYZAArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdRGBA(ADest^) := XYZAToStdRGBA(TXYZA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertXYZAArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := XYZAToAdobeRGBA(TXYZA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function XYZAToStdHSLA(const AXYZA: TXYZA): TStdHSLA;
begin Result := StdRGBAToStdHSLA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(AXYZA))) end;

procedure ConvertXYZAArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSLA(ADest^) := XYZAToStdHSLA(TXYZA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function XYZAToStdHSVA(const AXYZA: TXYZA): TStdHSVA;
begin Result := StdRGBAToStdHSVA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(AXYZA))) end;

procedure ConvertXYZAArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdHSVA(ADest^) := XYZAToStdHSVA(TXYZA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function XYZAToStdCMYK(const AXYZA: TXYZA): TStdCMYK;
begin Result := StdRGBAToStdCMYK(LinearRGBAToStdRGBA(XYZAToLinearRGBA(AXYZA))) end;

procedure ConvertXYZAArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TStdCMYK(ADest^) := XYZAToStdCMYK(TXYZA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function XYZAToExpandedPixel(const AXYZA: TXYZA): TExpandedPixel;
begin Result := LinearRGBAToExpandedPixel(XYZAToLinearRGBA(AXYZA)) end;

procedure ConvertXYZAArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := XYZAToExpandedPixel(TXYZA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertXYZAArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := XYZAToLinearRGBA(TXYZA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function XYZAToHSLAPixel(const AXYZA: TXYZA): THSLAPixel;
begin Result := ExpandedToHSLA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(AXYZA))) end;

procedure ConvertXYZAArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    THSLAPixel(ADest^) := XYZAToHSLAPixel(TXYZA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function XYZAToGSBAPixel(const AXYZA: TXYZA): TGSBAPixel;
begin Result := ExpandedToGSBA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(AXYZA))) end;

procedure ConvertXYZAArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := XYZAToGSBAPixel(TXYZA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertXYZAArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLabA(ADest^) := XYZAToLabA(TXYZA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function XYZAToLChA(const AXYZA: TXYZA): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(AXYZA)) end;

function XYZAToLChA(const AXYZA: TXYZA; const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
begin Result := LabAToLChA(XYZAToLabA(AXYZA,AReferenceWhite)) end;

procedure ConvertXYZAArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TXYZA); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLChA(ADest^) := XYZAToLChA(TXYZA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LabAToColor(const ALabA: TLabA): TColor;overload;
begin Result := BGRAToColor(StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA))))) end;

function LabAToColor(const ALabA: TLabA; const AReferenceWhite: TXYZReferenceWhite): TColor;overload;
begin Result := BGRAToColor(StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA,AReferenceWhite))))) end;

procedure ConvertLabAArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TColor(ADest^) := LabAToColor(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LabAToBGRAPixel(const ALabA: TLabA): TBGRAPixel;overload;
begin Result := StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA)))) end;

function LabAToBGRAPixel(const ALabA: TLabA; const AReferenceWhite: TXYZReferenceWhite): TBGRAPixel;overload;
begin Result := StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA,AReferenceWhite)))) end;

procedure ConvertLabAArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := LabAToBGRAPixel(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LabAToStdRGBA(const ALabA: TLabA): TStdRGBA;overload;
begin Result := LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA))) end;

function LabAToStdRGBA(const ALabA: TLabA; const AReferenceWhite: TXYZReferenceWhite): TStdRGBA;overload;
begin Result := LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA,AReferenceWhite))) end;

procedure ConvertLabAArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TStdRGBA(ADest^) := LabAToStdRGBA(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LabAToAdobeRGBA(const ALabA: TLabA): TAdobeRGBA;overload;
begin Result := XYZAToAdobeRGBA(LabAToXYZA(ALabA)) end;

function LabAToAdobeRGBA(const ALabA: TLabA; const AReferenceWhite: TXYZReferenceWhite): TAdobeRGBA;overload;
begin Result := XYZAToAdobeRGBA(LabAToXYZA(ALabA,AReferenceWhite)) end;

procedure ConvertLabAArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := LabAToAdobeRGBA(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LabAToStdHSLA(const ALabA: TLabA): TStdHSLA;overload;
begin Result := StdRGBAToStdHSLA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA)))) end;

function LabAToStdHSLA(const ALabA: TLabA; const AReferenceWhite: TXYZReferenceWhite): TStdHSLA;overload;
begin Result := StdRGBAToStdHSLA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA,AReferenceWhite)))) end;

procedure ConvertLabAArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TStdHSLA(ADest^) := LabAToStdHSLA(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LabAToStdHSVA(const ALabA: TLabA): TStdHSVA;overload;
begin Result := StdRGBAToStdHSVA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA)))) end;

function LabAToStdHSVA(const ALabA: TLabA; const AReferenceWhite: TXYZReferenceWhite): TStdHSVA;overload;
begin Result := StdRGBAToStdHSVA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA,AReferenceWhite)))) end;

procedure ConvertLabAArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TStdHSVA(ADest^) := LabAToStdHSVA(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LabAToStdCMYK(const ALabA: TLabA): TStdCMYK;overload;
begin Result := StdRGBAToStdCMYK(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA)))) end;

function LabAToStdCMYK(const ALabA: TLabA; const AReferenceWhite: TXYZReferenceWhite): TStdCMYK;overload;
begin Result := StdRGBAToStdCMYK(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(ALabA,AReferenceWhite)))) end;

procedure ConvertLabAArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TStdCMYK(ADest^) := LabAToStdCMYK(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LabAToExpandedPixel(const ALabA: TLabA): TExpandedPixel;overload;
begin Result := LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(ALabA))) end;

function LabAToExpandedPixel(const ALabA: TLabA; const AReferenceWhite: TXYZReferenceWhite): TExpandedPixel;overload;
begin Result := LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(ALabA,AReferenceWhite))) end;

procedure ConvertLabAArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := LabAToExpandedPixel(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LabAToLinearRGBA(const ALabA: TLabA): TLinearRGBA;overload;
begin Result := XYZAToLinearRGBA(LabAToXYZA(ALabA)) end;

function LabAToLinearRGBA(const ALabA: TLabA; const AReferenceWhite: TXYZReferenceWhite): TLinearRGBA;overload;
begin Result := XYZAToLinearRGBA(LabAToXYZA(ALabA,AReferenceWhite)) end;

procedure ConvertLabAArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := LabAToLinearRGBA(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LabAToHSLAPixel(const ALabA: TLabA): THSLAPixel;overload;
begin Result := ExpandedToHSLA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(ALabA)))) end;

function LabAToHSLAPixel(const ALabA: TLabA; const AReferenceWhite: TXYZReferenceWhite): THSLAPixel;overload;
begin Result := ExpandedToHSLA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(ALabA,AReferenceWhite)))) end;

procedure ConvertLabAArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    THSLAPixel(ADest^) := LabAToHSLAPixel(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LabAToGSBAPixel(const ALabA: TLabA): TGSBAPixel;overload;
begin Result := ExpandedToGSBA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(ALabA)))) end;

function LabAToGSBAPixel(const ALabA: TLabA; const AReferenceWhite: TXYZReferenceWhite): TGSBAPixel;overload;
begin Result := ExpandedToGSBA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(ALabA,AReferenceWhite)))) end;

procedure ConvertLabAArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := LabAToGSBAPixel(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertLabAArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TXYZA(ADest^) := LabAToXYZA(TLabA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertLabAArrayToLChAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLabA); ADestStride:integer=sizeOf(TLChA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLChA(ADest^) := LabAToLChA(TLabA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToColor(const ALChA: TLChA): TColor;overload;
begin Result := BGRAToColor(StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA)))))) end;

function LChAToColor(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): TColor;overload;
begin Result := BGRAToColor(StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite))))) end;

procedure ConvertLChAArrayToColorArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TColor); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TColor(ADest^) := LChAToColor(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToBGRAPixel(const ALChA: TLChA): TBGRAPixel;overload;
begin Result := StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA))))) end;

function LChAToBGRAPixel(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): TBGRAPixel;overload;
begin Result := StdRGBAToBGRAPixel(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite)))) end;

procedure ConvertLChAArrayToBGRAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TBGRAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TBGRAPixel(ADest^) := LChAToBGRAPixel(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToStdRGBA(const ALChA: TLChA): TStdRGBA;overload;
begin Result := LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA)))) end;

function LChAToStdRGBA(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): TStdRGBA;overload;
begin Result := LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite))) end;

procedure ConvertLChAArrayToStdRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TStdRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TStdRGBA(ADest^) := LChAToStdRGBA(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToAdobeRGBA(const ALChA: TLChA): TAdobeRGBA;overload;
begin Result := XYZAToAdobeRGBA(LabAToXYZA(LChAToLabA(ALChA))) end;

function LChAToAdobeRGBA(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): TAdobeRGBA;overload;
begin Result := XYZAToAdobeRGBA(LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite)) end;

procedure ConvertLChAArrayToAdobeRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TAdobeRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TAdobeRGBA(ADest^) := LChAToAdobeRGBA(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToStdHSLA(const ALChA: TLChA): TStdHSLA;overload;
begin Result := StdRGBAToStdHSLA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA))))) end;

function LChAToStdHSLA(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): TStdHSLA;overload;
begin Result := StdRGBAToStdHSLA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite)))) end;

procedure ConvertLChAArrayToStdHSLAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TStdHSLA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TStdHSLA(ADest^) := LChAToStdHSLA(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToStdHSVA(const ALChA: TLChA): TStdHSVA;overload;
begin Result := StdRGBAToStdHSVA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA))))) end;

function LChAToStdHSVA(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): TStdHSVA;overload;
begin Result := StdRGBAToStdHSVA(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite)))) end;

procedure ConvertLChAArrayToStdHSVAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TStdHSVA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TStdHSVA(ADest^) := LChAToStdHSVA(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToStdCMYK(const ALChA: TLChA): TStdCMYK;overload;
begin Result := StdRGBAToStdCMYK(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA))))) end;

function LChAToStdCMYK(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): TStdCMYK;overload;
begin Result := StdRGBAToStdCMYK(LinearRGBAToStdRGBA(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite)))) end;

procedure ConvertLChAArrayToStdCMYKArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TStdCMYK); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TStdCMYK(ADest^) := LChAToStdCMYK(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToExpandedPixel(const ALChA: TLChA): TExpandedPixel;overload;
begin Result := LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA)))) end;

function LChAToExpandedPixel(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): TExpandedPixel;overload;
begin Result := LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite))) end;

procedure ConvertLChAArrayToExpandedPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TExpandedPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TExpandedPixel(ADest^) := LChAToExpandedPixel(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToLinearRGBA(const ALChA: TLChA): TLinearRGBA;overload;
begin Result := XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA))) end;

function LChAToLinearRGBA(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): TLinearRGBA;overload;
begin Result := XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite)) end;

procedure ConvertLChAArrayToLinearRGBAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TLinearRGBA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TLinearRGBA(ADest^) := LChAToLinearRGBA(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToHSLAPixel(const ALChA: TLChA): THSLAPixel;overload;
begin Result := ExpandedToHSLA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA))))) end;

function LChAToHSLAPixel(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): THSLAPixel;overload;
begin Result := ExpandedToHSLA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite)))) end;

procedure ConvertLChAArrayToHSLAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(THSLAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    THSLAPixel(ADest^) := LChAToHSLAPixel(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToGSBAPixel(const ALChA: TLChA): TGSBAPixel;overload;
begin Result := ExpandedToGSBA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA))))) end;

function LChAToGSBAPixel(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): TGSBAPixel;overload;
begin Result := ExpandedToGSBA(LinearRGBAToExpandedPixel(XYZAToLinearRGBA(LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite)))) end;

procedure ConvertLChAArrayToGSBAPixelArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TGSBAPixel); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TGSBAPixel(ADest^) := LChAToGSBAPixel(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

function LChAToXYZA(const ALChA: TLChA): TXYZA;overload;
begin Result := LabAToXYZA(LChAToLabA(ALChA)) end;

function LChAToXYZA(const ALChA: TLChA; const AReferenceWhite: TXYZReferenceWhite): TXYZA;overload;
begin Result := LabAToXYZA(LChAToLabA(ALChA),AReferenceWhite) end;

procedure ConvertLChAArrayToXYZAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TXYZA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  if AReferenceWhite = nil then AReferenceWhite := @CurrentReferenceWhite;
  while ACount > 0 do begin
    TXYZA(ADest^) := LChAToXYZA(TLChA(ASource^), AReferenceWhite^);
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

procedure ConvertLChAArrayToLabAArray(ASource: pointer; ADest: Pointer; ACount: integer; ASourceStride:integer=sizeOf(TLChA); ADestStride:integer=sizeOf(TLabA); {%H-}AReferenceWhite: PXYZReferenceWhite=nil);
begin
  while ACount > 0 do begin
    TLabA(ADest^) := LChAToLabA(TLChA(ASource^));
    inc(PByte(ASource), ASourceStride); inc(PByte(ADest), ADestStride); dec(ACount); end;
end;

{TStdRGBA}

class function TStdRGBA.New(const ARed,AGreen,ABlue,AAlpha:single): TStdRGBA;
begin
  Result.red := ARed;
  Result.green := AGreen;
  Result.blue := ABlue;
  Result.alpha := AAlpha;
end;

class function TStdRGBA.New(const ARed,AGreen,ABlue:single): TStdRGBA;
begin
  Result.red := ARed;
  Result.green := AGreen;
  Result.blue := ABlue;
  Result.alpha := 1;
end;

{TAdobeRGBA}

class function TAdobeRGBA.New(const ARed,AGreen,ABlue,AAlpha:byte): TAdobeRGBA;
begin
  Result.red := ARed;
  Result.green := AGreen;
  Result.blue := ABlue;
  Result.alpha := AAlpha;
end;

class function TAdobeRGBA.New(const ARed,AGreen,ABlue:byte): TAdobeRGBA;
begin
  Result.red := ARed;
  Result.green := AGreen;
  Result.blue := ABlue;
  Result.alpha := 255;
end;

{TStdHSLA}

class function TStdHSLA.New(const AHue,ASaturation,ALightness,AAlpha:single): TStdHSLA;
begin
  Result.hue := AHue;
  Result.saturation := ASaturation;
  Result.lightness := ALightness;
  Result.alpha := AAlpha;
end;

class function TStdHSLA.New(const AHue,ASaturation,ALightness:single): TStdHSLA;
begin
  Result.hue := AHue;
  Result.saturation := ASaturation;
  Result.lightness := ALightness;
  Result.alpha := 1;
end;

{TStdHSVA}

class function TStdHSVA.New(const AHue,ASaturation,AValue,AAlpha:single): TStdHSVA;
begin
  Result.hue := AHue;
  Result.saturation := ASaturation;
  Result.value := AValue;
  Result.alpha := AAlpha;
end;

class function TStdHSVA.New(const AHue,ASaturation,AValue:single): TStdHSVA;
begin
  Result.hue := AHue;
  Result.saturation := ASaturation;
  Result.value := AValue;
  Result.alpha := 1;
end;

{TStdCMYK}

class function TStdCMYK.New(const ACyan,AMagenta,AYellow,ABlack:single): TStdCMYK;
begin
  Result.C := ACyan;
  Result.M := AMagenta;
  Result.Y := AYellow;
  Result.K := ABlack;
end;

{TLinearRGBA}

class function TLinearRGBA.New(const ARed,AGreen,ABlue,AAlpha:single): TLinearRGBA;
begin
  Result.red := ARed;
  Result.green := AGreen;
  Result.blue := ABlue;
  Result.alpha := AAlpha;
end;

class function TLinearRGBA.New(const ARed,AGreen,ABlue:single): TLinearRGBA;
begin
  Result.red := ARed;
  Result.green := AGreen;
  Result.blue := ABlue;
  Result.alpha := 1;
end;

{TXYZA}

class function TXYZA.New(const AX,AY,AZ,AAlpha:single): TXYZA;
begin
  Result.X := AX;
  Result.Y := AY;
  Result.Z := AZ;
  Result.alpha := AAlpha;
end;

class function TXYZA.New(const AX,AY,AZ:single): TXYZA;
begin
  Result.X := AX;
  Result.Y := AY;
  Result.Z := AZ;
  Result.alpha := 1;
end;

{TLabA}

class function TLabA.New(const ALightness,Aa,Ab,AAlpha:single): TLabA;
begin
  Result.L := ALightness;
  Result.a := Aa;
  Result.b := Ab;
  Result.alpha := AAlpha;
end;

class function TLabA.New(const ALightness,Aa,Ab:single): TLabA;
begin
  Result.L := ALightness;
  Result.a := Aa;
  Result.b := Ab;
  Result.alpha := 1;
end;

{TLChA}

class function TLChA.New(const ALightness,AChroma,AHue,AAlpha:single): TLChA;
begin
  Result.L := ALightness;
  Result.C := AChroma;
  Result.h := AHue;
  Result.alpha := AAlpha;
end;

class function TLChA.New(const ALightness,AChroma,AHue:single): TLChA;
begin
  Result.L := ALightness;
  Result.C := AChroma;
  Result.h := AHue;
  Result.alpha := 1;
end;

{ TColorColorspace }

class function TColorColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Red';
  1: result := 'Green';
  2: result := 'Blue';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TColorColorspace.GetChannelCount: integer;
begin result := 3 end;

class function TColorColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 255;
  1: result := 255;
  2: result := 255;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TColorColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TColorColorspace.GetName: string;
begin result := 'Color' end;

class function TColorColorspace.GetSize: integer;
begin result := sizeof(TColor) end;

class function TColorColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
//#
{  case AIndex of
  0: result := TColor(AColor^).red;
  1: result := TColor(AColor^).green;
  2: result := TColor(AColor^).blue;
  else raise ERangeError.Create('Index out of bounds');
  end;}
end;

class procedure TColorColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
//#
{  case AIndex of
  0: TColor(AColor^).red   := Round(Clamp(AValue,0,255));
  1: TColor(AColor^).green := Round(Clamp(AValue,0,255));
  2: TColor(AColor^).blue  := Round(Clamp(AValue,0,255));
  else raise ERangeError.Create('Index out of bounds');
  end;}
end;

class function TColorColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ TBGRAPixelColorspace }

class function TBGRAPixelColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Red';
  1: result := 'Green';
  2: result := 'Blue';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TBGRAPixelColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TBGRAPixelColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 255;
  1: result := 255;
  2: result := 255;
  3: result := 255;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TBGRAPixelColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TBGRAPixelColorspace.GetName: string;
begin result := 'BGRAPixel' end;

class function TBGRAPixelColorspace.GetSize: integer;
begin result := sizeof(TBGRAPixel) end;

class function TBGRAPixelColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TBGRAPixel(AColor^).red;
  1: result := TBGRAPixel(AColor^).green;
  2: result := TBGRAPixel(AColor^).blue;
  3: result := TBGRAPixel(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TBGRAPixelColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TBGRAPixel(AColor^).red := Round(Clamp(AValue,0,255));
  1: TBGRAPixel(AColor^).green := Round(Clamp(AValue,0,255));
  2: TBGRAPixel(AColor^).blue := Round(Clamp(AValue,0,255));
  3: TBGRAPixel(AColor^).alpha := Round(Clamp(AValue,0,255));
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TBGRAPixelColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ TStdRGBAColorspace }

class function TStdRGBAColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Red';
  1: result := 'Green';
  2: result := 'Blue';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdRGBAColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TStdRGBAColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 1;
  1: result := 1;
  2: result := 1;
  3: result := 1;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdRGBAColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdRGBAColorspace.GetName: string;
begin result := 'StdRGBA' end;

class function TStdRGBAColorspace.GetSize: integer;
begin result := sizeof(TStdRGBA) end;

class function TStdRGBAColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TStdRGBA(AColor^).red;
  1: result := TStdRGBA(AColor^).green;
  2: result := TStdRGBA(AColor^).blue;
  3: result := TStdRGBA(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TStdRGBAColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TStdRGBA(AColor^).red := AValue;
  1: TStdRGBA(AColor^).green := AValue;
  2: TStdRGBA(AColor^).blue := AValue;
  3: TStdRGBA(AColor^).alpha := AValue;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdRGBAColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ TAdobeRGBAColorspace }

class function TAdobeRGBAColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Red';
  1: result := 'Green';
  2: result := 'Blue';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TAdobeRGBAColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TAdobeRGBAColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 255;
  1: result := 255;
  2: result := 255;
  3: result := 255;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TAdobeRGBAColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TAdobeRGBAColorspace.GetName: string;
begin result := 'AdobeRGBA' end;

class function TAdobeRGBAColorspace.GetSize: integer;
begin result := sizeof(TAdobeRGBA) end;

class function TAdobeRGBAColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TAdobeRGBA(AColor^).red;
  1: result := TAdobeRGBA(AColor^).green;
  2: result := TAdobeRGBA(AColor^).blue;
  3: result := TAdobeRGBA(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TAdobeRGBAColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TAdobeRGBA(AColor^).red := Round(Clamp(AValue,0,255));
  1: TAdobeRGBA(AColor^).green := Round(Clamp(AValue,0,255));
  2: TAdobeRGBA(AColor^).blue := Round(Clamp(AValue,0,255));
  3: TAdobeRGBA(AColor^).alpha := Round(Clamp(AValue,0,255));
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TAdobeRGBAColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ TStdHSLAColorspace }

class function TStdHSLAColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Hue';
  1: result := 'Saturation';
  2: result := 'Lightness';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdHSLAColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TStdHSLAColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 360;
  1: result := 1;
  2: result := 1;
  3: result := 1;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdHSLAColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdHSLAColorspace.GetName: string;
begin result := 'StdHSLA' end;

class function TStdHSLAColorspace.GetSize: integer;
begin result := sizeof(TStdHSLA) end;

class function TStdHSLAColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TStdHSLA(AColor^).hue;
  1: result := TStdHSLA(AColor^).saturation;
  2: result := TStdHSLA(AColor^).lightness;
  3: result := TStdHSLA(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TStdHSLAColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TStdHSLA(AColor^).hue := AValue;
  1: TStdHSLA(AColor^).saturation := AValue;
  2: TStdHSLA(AColor^).lightness := AValue;
  3: TStdHSLA(AColor^).alpha := AValue;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdHSLAColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ TStdHSVAColorspace }

class function TStdHSVAColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Hue';
  1: result := 'Saturation';
  2: result := 'Value';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdHSVAColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TStdHSVAColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 360;
  1: result := 1;
  2: result := 1;
  3: result := 1;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdHSVAColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdHSVAColorspace.GetName: string;
begin result := 'StdHSVA' end;

class function TStdHSVAColorspace.GetSize: integer;
begin result := sizeof(TStdHSVA) end;

class function TStdHSVAColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TStdHSVA(AColor^).hue;
  1: result := TStdHSVA(AColor^).saturation;
  2: result := TStdHSVA(AColor^).value;
  3: result := TStdHSVA(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TStdHSVAColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TStdHSVA(AColor^).hue := AValue;
  1: TStdHSVA(AColor^).saturation := AValue;
  2: TStdHSVA(AColor^).value := AValue;
  3: TStdHSVA(AColor^).alpha := AValue;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdHSVAColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ TStdCMYKColorspace }

class function TStdCMYKColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Cyan';
  1: result := 'Magenta';
  2: result := 'Yellow';
  3: result := 'Black';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdCMYKColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TStdCMYKColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 1;
  1: result := 1;
  2: result := 1;
  3: result := 1;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdCMYKColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdCMYKColorspace.GetName: string;
begin result := 'StdCMYK' end;

class function TStdCMYKColorspace.GetSize: integer;
begin result := sizeof(TStdCMYK) end;

class function TStdCMYKColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TStdCMYK(AColor^).C;
  1: result := TStdCMYK(AColor^).M;
  2: result := TStdCMYK(AColor^).Y;
  3: result := TStdCMYK(AColor^).K;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TStdCMYKColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TStdCMYK(AColor^).C := AValue;
  1: TStdCMYK(AColor^).M := AValue;
  2: TStdCMYK(AColor^).Y := AValue;
  3: TStdCMYK(AColor^).K := AValue;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TStdCMYKColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ TExpandedPixelColorspace }

class function TExpandedPixelColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Red';
  1: result := 'Green';
  2: result := 'Blue';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TExpandedPixelColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TExpandedPixelColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 65535;
  1: result := 65535;
  2: result := 65535;
  3: result := 65535;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TExpandedPixelColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TExpandedPixelColorspace.GetName: string;
begin result := 'ExpandedPixel' end;

class function TExpandedPixelColorspace.GetSize: integer;
begin result := sizeof(TExpandedPixel) end;

class function TExpandedPixelColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TExpandedPixel(AColor^).red;
  1: result := TExpandedPixel(AColor^).green;
  2: result := TExpandedPixel(AColor^).blue;
  3: result := TExpandedPixel(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TExpandedPixelColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TExpandedPixel(AColor^).red := Round(Clamp(AValue,0,65535));
  1: TExpandedPixel(AColor^).green := Round(Clamp(AValue,0,65535));
  2: TExpandedPixel(AColor^).blue := Round(Clamp(AValue,0,65535));
  3: TExpandedPixel(AColor^).alpha := Round(Clamp(AValue,0,65535));
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TExpandedPixelColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ TLinearRGBAColorspace }

class function TLinearRGBAColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Red';
  1: result := 'Green';
  2: result := 'Blue';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLinearRGBAColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TLinearRGBAColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 1;
  1: result := 1;
  2: result := 1;
  3: result := 1;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLinearRGBAColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLinearRGBAColorspace.GetName: string;
begin result := 'LinearRGBA' end;

class function TLinearRGBAColorspace.GetSize: integer;
begin result := sizeof(TLinearRGBA) end;

class function TLinearRGBAColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TLinearRGBA(AColor^).red;
  1: result := TLinearRGBA(AColor^).green;
  2: result := TLinearRGBA(AColor^).blue;
  3: result := TLinearRGBA(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TLinearRGBAColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TLinearRGBA(AColor^).red := AValue;
  1: TLinearRGBA(AColor^).green := AValue;
  2: TLinearRGBA(AColor^).blue := AValue;
  3: TLinearRGBA(AColor^).alpha := AValue;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLinearRGBAColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ THSLAPixelColorspace }

class function THSLAPixelColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Hue';
  1: result := 'Saturation';
  2: result := 'Lightness';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function THSLAPixelColorspace.GetChannelCount: integer;
begin result := 4 end;

class function THSLAPixelColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 65535;
  1: result := 65535;
  2: result := 65535;
  3: result := 65535;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function THSLAPixelColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function THSLAPixelColorspace.GetName: string;
begin result := 'HSLAPixel' end;

class function THSLAPixelColorspace.GetSize: integer;
begin result := sizeof(THSLAPixel) end;

class function THSLAPixelColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := THSLAPixel(AColor^).hue;
  1: result := THSLAPixel(AColor^).saturation;
  2: result := THSLAPixel(AColor^).lightness;
  3: result := THSLAPixel(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure THSLAPixelColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: THSLAPixel(AColor^).hue := Round(Clamp(AValue,0,65535));
  1: THSLAPixel(AColor^).saturation := Round(Clamp(AValue,0,65535));
  2: THSLAPixel(AColor^).lightness := Round(Clamp(AValue,0,65535));
  3: THSLAPixel(AColor^).alpha := Round(Clamp(AValue,0,65535));
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function THSLAPixelColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ TGSBAPixelColorspace }

class function TGSBAPixelColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Hue';
  1: result := 'Saturation';
  2: result := 'Brightness';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TGSBAPixelColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TGSBAPixelColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 65535;
  1: result := 65535;
  2: result := 65535;
  3: result := 65535;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TGSBAPixelColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TGSBAPixelColorspace.GetName: string;
begin result := 'GSBAPixel' end;

class function TGSBAPixelColorspace.GetSize: integer;
begin result := sizeof(TGSBAPixel) end;

class function TGSBAPixelColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TGSBAPixel(AColor^).hue;
  1: result := TGSBAPixel(AColor^).saturation;
  2: result := TGSBAPixel(AColor^).lightness;
  3: result := TGSBAPixel(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TGSBAPixelColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TGSBAPixel(AColor^).hue := Round(Clamp(AValue,0,65535));
  1: TGSBAPixel(AColor^).saturation := Round(Clamp(AValue,0,65535));
  2: TGSBAPixel(AColor^).lightness := Round(Clamp(AValue,0,65535));
  3: TGSBAPixel(AColor^).alpha := Round(Clamp(AValue,0,65535));
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TGSBAPixelColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ TXYZAColorspace }

class function TXYZAColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'X';
  1: result := 'Y';
  2: result := 'Z';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TXYZAColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TXYZAColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 1;
  1: result := 1;
  2: result := 1;
  3: result := 1;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TXYZAColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TXYZAColorspace.GetName: string;
begin result := 'XYZA' end;

class function TXYZAColorspace.GetSize: integer;
begin result := sizeof(TXYZA) end;

class function TXYZAColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TXYZA(AColor^).X;
  1: result := TXYZA(AColor^).Y;
  2: result := TXYZA(AColor^).Z;
  3: result := TXYZA(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TXYZAColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TXYZA(AColor^).X := AValue;
  1: TXYZA(AColor^).Y := AValue;
  2: TXYZA(AColor^).Z := AValue;
  3: TXYZA(AColor^).alpha := AValue;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TXYZAColorspace.HasReferenceWhite: boolean;
begin result := False end;


{ TLabAColorspace }

class function TLabAColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Lightness';
  1: result := 'a';
  2: result := 'b';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLabAColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TLabAColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 100;
  1: result := 127;
  2: result := 127;
  3: result := 1;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLabAColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := -128;
  2: result := -128;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLabAColorspace.GetName: string;
begin result := 'LabA' end;

class function TLabAColorspace.GetSize: integer;
begin result := sizeof(TLabA) end;

class function TLabAColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TLabA(AColor^).L;
  1: result := TLabA(AColor^).a;
  2: result := TLabA(AColor^).b;
  3: result := TLabA(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TLabAColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TLabA(AColor^).L := AValue;
  1: TLabA(AColor^).a := AValue;
  2: TLabA(AColor^).b := AValue;
  3: TLabA(AColor^).alpha := AValue;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLabAColorspace.HasReferenceWhite: boolean;
begin result := True end;


{ TLChAColorspace }

class function TLChAColorspace.GetChannelName(AIndex: integer): string;
begin
  case AIndex of
  0: result := 'Lightness';
  1: result := 'Chroma';
  2: result := 'Hue';
  3: result := 'Alpha';
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLChAColorspace.GetChannelCount: integer;
begin result := 4 end;

class function TLChAColorspace.GetMaxValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 100;
  1: result := 180;
  2: result := 360;
  3: result := 1;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLChAColorspace.GetMinValue(AIndex: integer): single;
begin
  case AIndex of
  0: result := 0;
  1: result := 0;
  2: result := 0;
  3: result := 0;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLChAColorspace.GetName: string;
begin result := 'LChA' end;

class function TLChAColorspace.GetSize: integer;
begin result := sizeof(TLChA) end;

class function TLChAColorspace.GetChannel(AColor: Pointer; AIndex: integer): single;
begin
  case AIndex of
  0: result := TLChA(AColor^).L;
  1: result := TLChA(AColor^).C;
  2: result := TLChA(AColor^).h;
  3: result := TLChA(AColor^).alpha;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class procedure TLChAColorspace.SetChannel(AColor: Pointer; AIndex: integer; AValue: single);
begin
  case AIndex of
  0: TLChA(AColor^).L := AValue;
  1: TLChA(AColor^).C := AValue;
  2: TLChA(AColor^).h := AValue;
  3: TLChA(AColor^).alpha := AValue;
  else raise ERangeError.Create('Index out of bounds');
  end;
end;

class function TLChAColorspace.HasReferenceWhite: boolean;
begin result := True end;


{$IFDEF OBJ}
{TColorHelper}

class function TColorHelper.New(const ARed,AGreen,ABlue:byte): TColor;
begin Result := BGRAGraphics.RGBToColor(ARed,AGreen,ABlue) end;

class function TColorHelper.Colorspace: TColorspaceAny; static;
begin result := TColorColorspace end;

function TColorHelper.GetRed: byte;
begin result := self and $ff end;

function TColorHelper.GetGreen: byte;
begin result := (self shr 8) and $ff end;

function TColorHelper.GetBlue: byte;
begin result := (self shr 16) and $ff end;

procedure TColorHelper.SetRed(AValue: byte);
begin self := (self and $ffff00) or AValue end;

procedure TColorHelper.SetGreen(AValue: byte);
begin self := (self and $ff00ff) or (AValue shl 8) end;

procedure TColorHelper.SetBlue(AValue: byte);
begin self := (self and $00ffff) or (AValue shl 16) end;

function TColorHelper.ToBGRAPixel: TBGRAPixel;overload;
begin Result := ColorToBGRA(Self) end;

function TColorHelper.ToBGRAPixel(AAlpha: byte): TBGRAPixel;overload;
begin result := ColorToBGRA(self, AAlpha) end;

function TColorHelper.ToStdRGBA: TStdRGBA;overload;
begin Result := ColorToStdRGBA(Self) end;

function TColorHelper.ToStdRGBA(AAlpha: single): TStdRGBA;overload;
begin result := ColorToStdRGBA(self, AAlpha) end;

function TColorHelper.ToAdobeRGBA: TAdobeRGBA;overload;
begin Result := ColorToAdobeRGBA(Self) end;

function TColorHelper.ToAdobeRGBA(AAlpha: byte): TAdobeRGBA;overload;
begin result := ColorToAdobeRGBA(self, AAlpha) end;

function TColorHelper.ToStdHSLA: TStdHSLA;overload;
begin Result := ColorToStdHSLA(Self) end;

function TColorHelper.ToStdHSLA(AAlpha: single): TStdHSLA;overload;
begin result := ColorToStdHSLA(self, AAlpha) end;

function TColorHelper.ToStdHSVA: TStdHSVA;overload;
begin Result := ColorToStdHSVA(Self) end;

function TColorHelper.ToStdHSVA(AAlpha: single): TStdHSVA;overload;
begin result := ColorToStdHSVA(self, AAlpha) end;

function TColorHelper.ToStdCMYK: TStdCMYK;
begin Result := ColorToStdCMYK(Self) end;

function TColorHelper.ToExpandedPixel: TExpandedPixel;overload;
begin Result := ColorToExpandedPixel(Self) end;

function TColorHelper.ToExpandedPixel(AAlpha: BGRAWord): TExpandedPixel;overload;
begin result := ColorToExpandedPixel(self, AAlpha) end;

function TColorHelper.ToLinearRGBA: TLinearRGBA;overload;
begin Result := ColorToLinearRGBA(Self) end;

function TColorHelper.ToLinearRGBA(AAlpha: single): TLinearRGBA;overload;
begin result := ColorToLinearRGBA(self, AAlpha) end;

function TColorHelper.ToHSLAPixel: THSLAPixel;overload;
begin Result := ColorToHSLAPixel(Self) end;

function TColorHelper.ToHSLAPixel(AAlpha: BGRAWord): THSLAPixel;overload;
begin result := ColorToHSLAPixel(self, AAlpha) end;

function TColorHelper.ToGSBAPixel: TGSBAPixel;overload;
begin Result := ColorToGSBAPixel(Self) end;

function TColorHelper.ToGSBAPixel(AAlpha: BGRAWord): TGSBAPixel;overload;
begin result := ColorToGSBAPixel(self, AAlpha) end;

function TColorHelper.ToXYZA: TXYZA;overload;
begin Result := ColorToXYZA(Self) end;

function TColorHelper.ToXYZA(AAlpha: single): TXYZA;overload;
begin result := ColorToXYZA(self, AAlpha) end;

function TColorHelper.ToLabA: TLabA;overload;
begin Result := ColorToLabA(Self) end;

function TColorHelper.ToLabA(AAlpha: single): TLabA;overload;
begin result := ColorToLabA(self, AAlpha) end;

function TColorHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;overload;
begin Result := ColorToLabA(Self,AReferenceWhite) end;

function TColorHelper.ToLChA: TLChA;overload;
begin Result := ColorToLChA(Self) end;

function TColorHelper.ToLChA(AAlpha: single): TLChA;overload;
begin result := ColorToLChA(self, AAlpha) end;

function TColorHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;overload;
begin Result := ColorToLChA(Self,AReferenceWhite) end;

procedure TColorHelper.FromBGRAPixel(AValue: TBGRAPixel);
begin Self := BGRAToColor(AValue) end;

procedure TColorHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToColor(AValue) end;

procedure TColorHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToColor(AValue) end;

procedure TColorHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToColor(AValue) end;

procedure TColorHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToColor(AValue) end;

procedure TColorHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToColor(AValue) end;

procedure TColorHelper.FromExpandedPixel(AValue: TExpandedPixel);
begin Self := ExpandedPixelToColor(AValue) end;

procedure TColorHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToColor(AValue) end;

procedure TColorHelper.FromHSLAPixel(AValue: THSLAPixel);
begin Self := HSLAPixelToColor(AValue) end;

procedure TColorHelper.FromGSBAPixel(AValue: TGSBAPixel);
begin Self := GSBAPixelToColor(AValue) end;

procedure TColorHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToColor(AValue) end;

procedure TColorHelper.FromLabA(AValue: TLabA); overload;
begin Self := LabAToColor(AValue) end;

procedure TColorHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite); overload;
begin Self := LabAToColor(AValue,AReferenceWhite) end;

procedure TColorHelper.FromLChA(AValue: TLChA); overload;
begin Self := LChAToColor(AValue) end;

procedure TColorHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite); overload;
begin Self := LChAToColor(AValue,AReferenceWhite) end;

{$ENDIF}
{TBGRAPixelHelper}

class function TBGRAPixelHelper.New(const ARed,AGreen,ABlue,AAlpha:byte): TBGRAPixel;
begin
  Result.red := ARed;
  Result.green := AGreen;
  Result.blue := ABlue;
  Result.alpha := AAlpha;
end;

class function TBGRAPixelHelper.New(const ARed,AGreen,ABlue:byte): TBGRAPixel;
begin
  Result.red := ARed;
  Result.green := AGreen;
  Result.blue := ABlue;
  Result.alpha := 255;
end;

class function TBGRAPixelHelper.Colorspace: TColorspaceAny;
begin result := TBGRAPixelColorspace end;

function TBGRAPixelHelper.ToStdRGBA: TStdRGBA;
begin Result := BGRAPixelToStdRGBA(Self) end;

function TBGRAPixelHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := BGRAPixelToAdobeRGBA(Self) end;

function TBGRAPixelHelper.ToStdHSLA: TStdHSLA;
begin Result := BGRAPixelToStdHSLA(Self) end;

function TBGRAPixelHelper.ToStdHSVA: TStdHSVA;
begin Result := BGRAPixelToStdHSVA(Self) end;

function TBGRAPixelHelper.ToStdCMYK: TStdCMYK;
begin Result := BGRAPixelToStdCMYK(Self) end;

function TBGRAPixelHelper.ToLinearRGBA: TLinearRGBA;
begin Result := BGRAPixelToLinearRGBA(Self) end;

function TBGRAPixelHelper.ToXYZA: TXYZA;
begin Result := BGRAPixelToXYZA(Self) end;

function TBGRAPixelHelper.ToLabA: TLabA;
begin Result := BGRAPixelToLabA(Self) end;

function TBGRAPixelHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;
begin Result := BGRAPixelToLabA(Self,AReferenceWhite) end;

function TBGRAPixelHelper.ToLChA: TLChA;
begin Result := BGRAPixelToLChA(Self) end;

function TBGRAPixelHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;
begin Result := BGRAPixelToLChA(Self,AReferenceWhite) end;

procedure TBGRAPixelHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToBGRAPixel(AValue) end;

procedure TBGRAPixelHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToBGRAPixel(AValue) end;

procedure TBGRAPixelHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToBGRAPixel(AValue) end;

procedure TBGRAPixelHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToBGRAPixel(AValue) end;

procedure TBGRAPixelHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToBGRAPixel(AValue) end;

procedure TBGRAPixelHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToBGRAPixel(AValue) end;

procedure TBGRAPixelHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToBGRAPixel(AValue) end;

procedure TBGRAPixelHelper.FromLabA(AValue: TLabA);
begin Self := LabAToBGRAPixel(AValue) end;

procedure TBGRAPixelHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LabAToBGRAPixel(AValue,AReferenceWhite) end;

procedure TBGRAPixelHelper.FromLChA(AValue: TLChA);
begin Self := LChAToBGRAPixel(AValue) end;

procedure TBGRAPixelHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LChAToBGRAPixel(AValue,AReferenceWhite) end;

{TStdRGBAHelper}

class function TStdRGBAHelper.Colorspace: TColorspaceAny;
begin result := TStdRGBAColorspace end;

function TStdRGBAHelper.ToColor: TColor;
begin Result := StdRGBAToColor(Self) end;

function TStdRGBAHelper.ToBGRAPixel: TBGRAPixel;
begin Result := StdRGBAToBGRAPixel(Self) end;

function TStdRGBAHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := StdRGBAToAdobeRGBA(Self) end;

function TStdRGBAHelper.ToStdHSLA: TStdHSLA;
begin Result := StdRGBAToStdHSLA(Self) end;

function TStdRGBAHelper.ToStdHSVA: TStdHSVA;
begin Result := StdRGBAToStdHSVA(Self) end;

function TStdRGBAHelper.ToStdCMYK: TStdCMYK;
begin Result := StdRGBAToStdCMYK(Self) end;

function TStdRGBAHelper.ToExpandedPixel: TExpandedPixel;
begin Result := StdRGBAToExpandedPixel(Self) end;

function TStdRGBAHelper.ToLinearRGBA: TLinearRGBA;
begin Result := StdRGBAToLinearRGBA(Self) end;

function TStdRGBAHelper.ToHSLAPixel: THSLAPixel;
begin Result := StdRGBAToHSLAPixel(Self) end;

function TStdRGBAHelper.ToGSBAPixel: TGSBAPixel;
begin Result := StdRGBAToGSBAPixel(Self) end;

function TStdRGBAHelper.ToXYZA: TXYZA;
begin Result := StdRGBAToXYZA(Self) end;

function TStdRGBAHelper.ToLabA: TLabA;
begin Result := StdRGBAToLabA(Self) end;

function TStdRGBAHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;
begin Result := StdRGBAToLabA(Self,AReferenceWhite) end;

function TStdRGBAHelper.ToLChA: TLChA;
begin Result := StdRGBAToLChA(Self) end;

function TStdRGBAHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;
begin Result := StdRGBAToLChA(Self,AReferenceWhite) end;

procedure TStdRGBAHelper.FromColor(AValue: TColor);
begin Self := ColorToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromBGRAPixel(AValue: TBGRAPixel);
begin Self := BGRAPixelToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromExpandedPixel(AValue: TExpandedPixel);
begin Self := ExpandedPixelToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromHSLAPixel(AValue: THSLAPixel);
begin Self := HSLAPixelToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromGSBAPixel(AValue: TGSBAPixel);
begin Self := GSBAPixelToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromLabA(AValue: TLabA);
begin Self := LabAToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LabAToStdRGBA(AValue,AReferenceWhite) end;

procedure TStdRGBAHelper.FromLChA(AValue: TLChA);
begin Self := LChAToStdRGBA(AValue) end;

procedure TStdRGBAHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LChAToStdRGBA(AValue,AReferenceWhite) end;

{TAdobeRGBAHelper}

class function TAdobeRGBAHelper.Colorspace: TColorspaceAny;
begin result := TAdobeRGBAColorspace end;

function TAdobeRGBAHelper.ToColor: TColor;
begin Result := AdobeRGBAToColor(Self) end;

function TAdobeRGBAHelper.ToBGRAPixel: TBGRAPixel;
begin Result := AdobeRGBAToBGRAPixel(Self) end;

function TAdobeRGBAHelper.ToStdRGBA: TStdRGBA;
begin Result := AdobeRGBAToStdRGBA(Self) end;

function TAdobeRGBAHelper.ToStdHSLA: TStdHSLA;
begin Result := AdobeRGBAToStdHSLA(Self) end;

function TAdobeRGBAHelper.ToStdHSVA: TStdHSVA;
begin Result := AdobeRGBAToStdHSVA(Self) end;

function TAdobeRGBAHelper.ToStdCMYK: TStdCMYK;
begin Result := AdobeRGBAToStdCMYK(Self) end;

function TAdobeRGBAHelper.ToExpandedPixel: TExpandedPixel;
begin Result := AdobeRGBAToExpandedPixel(Self) end;

function TAdobeRGBAHelper.ToLinearRGBA: TLinearRGBA;
begin Result := AdobeRGBAToLinearRGBA(Self) end;

function TAdobeRGBAHelper.ToHSLAPixel: THSLAPixel;
begin Result := AdobeRGBAToHSLAPixel(Self) end;

function TAdobeRGBAHelper.ToGSBAPixel: TGSBAPixel;
begin Result := AdobeRGBAToGSBAPixel(Self) end;

function TAdobeRGBAHelper.ToXYZA: TXYZA;
begin Result := AdobeRGBAToXYZA(Self) end;

function TAdobeRGBAHelper.ToLabA: TLabA;
begin Result := AdobeRGBAToLabA(Self) end;

function TAdobeRGBAHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;
begin Result := AdobeRGBAToLabA(Self,AReferenceWhite) end;

function TAdobeRGBAHelper.ToLChA: TLChA;
begin Result := AdobeRGBAToLChA(Self) end;

function TAdobeRGBAHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;
begin Result := AdobeRGBAToLChA(Self,AReferenceWhite) end;

procedure TAdobeRGBAHelper.FromColor(AValue: TColor);
begin Self := ColorToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromBGRAPixel(AValue: TBGRAPixel);
begin Self := BGRAPixelToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromExpandedPixel(AValue: TExpandedPixel);
begin Self := ExpandedPixelToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromHSLAPixel(AValue: THSLAPixel);
begin Self := HSLAPixelToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromGSBAPixel(AValue: TGSBAPixel);
begin Self := GSBAPixelToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromLabA(AValue: TLabA);
begin Self := LabAToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LabAToAdobeRGBA(AValue,AReferenceWhite) end;

procedure TAdobeRGBAHelper.FromLChA(AValue: TLChA);
begin Self := LChAToAdobeRGBA(AValue) end;

procedure TAdobeRGBAHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LChAToAdobeRGBA(AValue,AReferenceWhite) end;

{TStdHSLAHelper}

class function TStdHSLAHelper.Colorspace: TColorspaceAny;
begin result := TStdHSLAColorspace end;

function TStdHSLAHelper.ToColor: TColor;
begin Result := StdHSLAToColor(Self) end;

function TStdHSLAHelper.ToBGRAPixel: TBGRAPixel;
begin Result := StdHSLAToBGRAPixel(Self) end;

function TStdHSLAHelper.ToStdRGBA: TStdRGBA;
begin Result := StdHSLAToStdRGBA(Self) end;

function TStdHSLAHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := StdHSLAToAdobeRGBA(Self) end;

function TStdHSLAHelper.ToStdHSVA: TStdHSVA;
begin Result := StdHSLAToStdHSVA(Self) end;

function TStdHSLAHelper.ToStdCMYK: TStdCMYK;
begin Result := StdHSLAToStdCMYK(Self) end;

function TStdHSLAHelper.ToExpandedPixel: TExpandedPixel;
begin Result := StdHSLAToExpandedPixel(Self) end;

function TStdHSLAHelper.ToLinearRGBA: TLinearRGBA;
begin Result := StdHSLAToLinearRGBA(Self) end;

function TStdHSLAHelper.ToHSLAPixel: THSLAPixel;
begin Result := StdHSLAToHSLAPixel(Self) end;

function TStdHSLAHelper.ToGSBAPixel: TGSBAPixel;
begin Result := StdHSLAToGSBAPixel(Self) end;

function TStdHSLAHelper.ToXYZA: TXYZA;
begin Result := StdHSLAToXYZA(Self) end;

function TStdHSLAHelper.ToLabA: TLabA;
begin Result := StdHSLAToLabA(Self) end;

function TStdHSLAHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;
begin Result := StdHSLAToLabA(Self,AReferenceWhite) end;

function TStdHSLAHelper.ToLChA: TLChA;
begin Result := StdHSLAToLChA(Self) end;

function TStdHSLAHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;
begin Result := StdHSLAToLChA(Self,AReferenceWhite) end;

procedure TStdHSLAHelper.FromColor(AValue: TColor);
begin Self := ColorToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromBGRAPixel(AValue: TBGRAPixel);
begin Self := BGRAPixelToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromExpandedPixel(AValue: TExpandedPixel);
begin Self := ExpandedPixelToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromHSLAPixel(AValue: THSLAPixel);
begin Self := HSLAPixelToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromGSBAPixel(AValue: TGSBAPixel);
begin Self := GSBAPixelToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromLabA(AValue: TLabA);
begin Self := LabAToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LabAToStdHSLA(AValue,AReferenceWhite) end;

procedure TStdHSLAHelper.FromLChA(AValue: TLChA);
begin Self := LChAToStdHSLA(AValue) end;

procedure TStdHSLAHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LChAToStdHSLA(AValue,AReferenceWhite) end;

{TStdHSVAHelper}

class function TStdHSVAHelper.Colorspace: TColorspaceAny;
begin result := TStdHSVAColorspace end;

function TStdHSVAHelper.ToColor: TColor;
begin Result := StdHSVAToColor(Self) end;

function TStdHSVAHelper.ToBGRAPixel: TBGRAPixel;
begin Result := StdHSVAToBGRAPixel(Self) end;

function TStdHSVAHelper.ToStdRGBA: TStdRGBA;
begin Result := StdHSVAToStdRGBA(Self) end;

function TStdHSVAHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := StdHSVAToAdobeRGBA(Self) end;

function TStdHSVAHelper.ToStdHSLA: TStdHSLA;
begin Result := StdHSVAToStdHSLA(Self) end;

function TStdHSVAHelper.ToStdCMYK: TStdCMYK;
begin Result := StdHSVAToStdCMYK(Self) end;

function TStdHSVAHelper.ToExpandedPixel: TExpandedPixel;
begin Result := StdHSVAToExpandedPixel(Self) end;

function TStdHSVAHelper.ToLinearRGBA: TLinearRGBA;
begin Result := StdHSVAToLinearRGBA(Self) end;

function TStdHSVAHelper.ToHSLAPixel: THSLAPixel;
begin Result := StdHSVAToHSLAPixel(Self) end;

function TStdHSVAHelper.ToGSBAPixel: TGSBAPixel;
begin Result := StdHSVAToGSBAPixel(Self) end;

function TStdHSVAHelper.ToXYZA: TXYZA;
begin Result := StdHSVAToXYZA(Self) end;

function TStdHSVAHelper.ToLabA: TLabA;
begin Result := StdHSVAToLabA(Self) end;

function TStdHSVAHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;
begin Result := StdHSVAToLabA(Self,AReferenceWhite) end;

function TStdHSVAHelper.ToLChA: TLChA;
begin Result := StdHSVAToLChA(Self) end;

function TStdHSVAHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;
begin Result := StdHSVAToLChA(Self,AReferenceWhite) end;

procedure TStdHSVAHelper.FromColor(AValue: TColor);
begin Self := ColorToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromBGRAPixel(AValue: TBGRAPixel);
begin Self := BGRAPixelToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromExpandedPixel(AValue: TExpandedPixel);
begin Self := ExpandedPixelToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromHSLAPixel(AValue: THSLAPixel);
begin Self := HSLAPixelToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromGSBAPixel(AValue: TGSBAPixel);
begin Self := GSBAPixelToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromLabA(AValue: TLabA);
begin Self := LabAToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LabAToStdHSVA(AValue,AReferenceWhite) end;

procedure TStdHSVAHelper.FromLChA(AValue: TLChA);
begin Self := LChAToStdHSVA(AValue) end;

procedure TStdHSVAHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LChAToStdHSVA(AValue,AReferenceWhite) end;

{TStdCMYKHelper}

class function TStdCMYKHelper.Colorspace: TColorspaceAny;
begin result := TStdCMYKColorspace end;

function TStdCMYKHelper.ToColor: TColor;
begin Result := StdCMYKToColor(Self) end;

function TStdCMYKHelper.ToBGRAPixel: TBGRAPixel;
begin Result := StdCMYKToBGRAPixel(Self) end;

function TStdCMYKHelper.ToBGRAPixel(AAlpha: byte): TBGRAPixel;
begin result := StdCMYKToBGRAPixel(self, AAlpha) end;

function TStdCMYKHelper.ToStdRGBA: TStdRGBA;
begin Result := StdCMYKToStdRGBA(Self) end;

function TStdCMYKHelper.ToStdRGBA(AAlpha: single): TStdRGBA;
begin result := StdCMYKToStdRGBA(self, AAlpha) end;

function TStdCMYKHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := StdCMYKToAdobeRGBA(Self) end;

function TStdCMYKHelper.ToAdobeRGBA(AAlpha: byte): TAdobeRGBA;
begin result := StdCMYKToAdobeRGBA(self, AAlpha) end;

function TStdCMYKHelper.ToStdHSLA: TStdHSLA;
begin Result := StdCMYKToStdHSLA(Self) end;

function TStdCMYKHelper.ToStdHSLA(AAlpha: single): TStdHSLA;
begin result := StdCMYKToStdHSLA(self, AAlpha) end;

function TStdCMYKHelper.ToStdHSVA: TStdHSVA;
begin Result := StdCMYKToStdHSVA(Self) end;

function TStdCMYKHelper.ToStdHSVA(AAlpha: single): TStdHSVA;
begin result := StdCMYKToStdHSVA(self, AAlpha) end;

function TStdCMYKHelper.ToExpandedPixel: TExpandedPixel;
begin Result := StdCMYKToExpandedPixel(Self) end;

function TStdCMYKHelper.ToExpandedPixel(AAlpha: BGRAWord): TExpandedPixel;
begin result := StdCMYKToExpandedPixel(self, AAlpha) end;

function TStdCMYKHelper.ToLinearRGBA: TLinearRGBA;
begin Result := StdCMYKToLinearRGBA(Self) end;

function TStdCMYKHelper.ToLinearRGBA(AAlpha: single): TLinearRGBA;
begin result := StdCMYKToLinearRGBA(self, AAlpha) end;

function TStdCMYKHelper.ToHSLAPixel: THSLAPixel;
begin Result := StdCMYKToHSLAPixel(Self) end;

function TStdCMYKHelper.ToHSLAPixel(AAlpha: BGRAWord): THSLAPixel;
begin result := StdCMYKToHSLAPixel(self, AAlpha) end;

function TStdCMYKHelper.ToGSBAPixel: TGSBAPixel;
begin Result := StdCMYKToGSBAPixel(Self) end;

function TStdCMYKHelper.ToGSBAPixel(AAlpha: BGRAWord): TGSBAPixel;
begin result := StdCMYKToGSBAPixel(self, AAlpha) end;

function TStdCMYKHelper.ToXYZA: TXYZA;
begin Result := StdCMYKToXYZA(Self) end;

function TStdCMYKHelper.ToXYZA(AAlpha: single): TXYZA;
begin result := StdCMYKToXYZA(self, AAlpha) end;

function TStdCMYKHelper.ToLabA: TLabA;
begin Result := StdCMYKToLabA(Self) end;

function TStdCMYKHelper.ToLabA(AAlpha: single): TLabA;
begin result := StdCMYKToLabA(self, AAlpha) end;

function TStdCMYKHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;
begin Result := StdCMYKToLabA(Self,AReferenceWhite) end;

function TStdCMYKHelper.ToLChA: TLChA;
begin Result := StdCMYKToLChA(Self) end;

function TStdCMYKHelper.ToLChA(AAlpha: single): TLChA;
begin result := StdCMYKToLChA(self, AAlpha) end;

function TStdCMYKHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;
begin Result := StdCMYKToLChA(Self,AReferenceWhite) end;

procedure TStdCMYKHelper.FromColor(AValue: TColor);
begin Self := ColorToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromBGRAPixel(AValue: TBGRAPixel);
begin Self := BGRAPixelToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromExpandedPixel(AValue: TExpandedPixel);
begin Self := ExpandedPixelToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromHSLAPixel(AValue: THSLAPixel);
begin Self := HSLAPixelToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromGSBAPixel(AValue: TGSBAPixel);
begin Self := GSBAPixelToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromLabA(AValue: TLabA);
begin Self := LabAToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LabAToStdCMYK(AValue,AReferenceWhite) end;

procedure TStdCMYKHelper.FromLChA(AValue: TLChA);
begin Self := LChAToStdCMYK(AValue) end;

procedure TStdCMYKHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LChAToStdCMYK(AValue,AReferenceWhite) end;

{TExpandedPixelHelper}

class function TExpandedPixelHelper.New(const ARed,AGreen,ABlue,AAlpha:BGRAWord): TExpandedPixel;
begin
  Result.red := ARed;
  Result.green := AGreen;
  Result.blue := ABlue;
  Result.alpha := AAlpha;
end;

class function TExpandedPixelHelper.New(const ARed,AGreen,ABlue:BGRAWord): TExpandedPixel;
begin
  Result.red := ARed;
  Result.green := AGreen;
  Result.blue := ABlue;
  Result.alpha := 65535;
end;

class function TExpandedPixelHelper.Colorspace: TColorspaceAny;
begin result := TExpandedPixelColorspace end;

function TExpandedPixelHelper.ToStdRGBA: TStdRGBA;
begin Result := ExpandedPixelToStdRGBA(Self) end;

function TExpandedPixelHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := ExpandedPixelToAdobeRGBA(Self) end;

function TExpandedPixelHelper.ToStdHSLA: TStdHSLA;
begin Result := ExpandedPixelToStdHSLA(Self) end;

function TExpandedPixelHelper.ToStdHSVA: TStdHSVA;
begin Result := ExpandedPixelToStdHSVA(Self) end;

function TExpandedPixelHelper.ToStdCMYK: TStdCMYK;
begin Result := ExpandedPixelToStdCMYK(Self) end;

function TExpandedPixelHelper.ToLinearRGBA: TLinearRGBA;
begin Result := ExpandedPixelToLinearRGBA(Self) end;

function TExpandedPixelHelper.ToXYZA: TXYZA;
begin Result := ExpandedPixelToXYZA(Self) end;

function TExpandedPixelHelper.ToLabA: TLabA;
begin Result := ExpandedPixelToLabA(Self) end;

function TExpandedPixelHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;
begin Result := ExpandedPixelToLabA(Self,AReferenceWhite) end;

function TExpandedPixelHelper.ToLChA: TLChA;
begin Result := ExpandedPixelToLChA(Self) end;

function TExpandedPixelHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;
begin Result := ExpandedPixelToLChA(Self,AReferenceWhite) end;

procedure TExpandedPixelHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToExpandedPixel(AValue) end;

procedure TExpandedPixelHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToExpandedPixel(AValue) end;

procedure TExpandedPixelHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToExpandedPixel(AValue) end;

procedure TExpandedPixelHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToExpandedPixel(AValue) end;

procedure TExpandedPixelHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToExpandedPixel(AValue) end;

procedure TExpandedPixelHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToExpandedPixel(AValue) end;

procedure TExpandedPixelHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToExpandedPixel(AValue) end;

procedure TExpandedPixelHelper.FromLabA(AValue: TLabA);
begin Self := LabAToExpandedPixel(AValue) end;

procedure TExpandedPixelHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LabAToExpandedPixel(AValue,AReferenceWhite) end;

procedure TExpandedPixelHelper.FromLChA(AValue: TLChA);
begin Self := LChAToExpandedPixel(AValue) end;

procedure TExpandedPixelHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LChAToExpandedPixel(AValue,AReferenceWhite) end;

{TLinearRGBAHelper}

class function TLinearRGBAHelper.Colorspace: TColorspaceAny;
begin result := TLinearRGBAColorspace end;

function TLinearRGBAHelper.ToColor: TColor;
begin Result := LinearRGBAToColor(Self) end;

function TLinearRGBAHelper.ToBGRAPixel: TBGRAPixel;
begin Result := LinearRGBAToBGRAPixel(Self) end;

function TLinearRGBAHelper.ToStdRGBA: TStdRGBA;
begin Result := LinearRGBAToStdRGBA(Self) end;

function TLinearRGBAHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := LinearRGBAToAdobeRGBA(Self) end;

function TLinearRGBAHelper.ToStdHSLA: TStdHSLA;
begin Result := LinearRGBAToStdHSLA(Self) end;

function TLinearRGBAHelper.ToStdHSVA: TStdHSVA;
begin Result := LinearRGBAToStdHSVA(Self) end;

function TLinearRGBAHelper.ToStdCMYK: TStdCMYK;
begin Result := LinearRGBAToStdCMYK(Self) end;

function TLinearRGBAHelper.ToExpandedPixel: TExpandedPixel;
begin Result := LinearRGBAToExpandedPixel(Self) end;

function TLinearRGBAHelper.ToHSLAPixel: THSLAPixel;
begin Result := LinearRGBAToHSLAPixel(Self) end;

function TLinearRGBAHelper.ToGSBAPixel: TGSBAPixel;
begin Result := LinearRGBAToGSBAPixel(Self) end;

function TLinearRGBAHelper.ToXYZA: TXYZA;
begin Result := LinearRGBAToXYZA(Self) end;

function TLinearRGBAHelper.ToLabA: TLabA;
begin Result := LinearRGBAToLabA(Self) end;

function TLinearRGBAHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;
begin Result := LinearRGBAToLabA(Self,AReferenceWhite) end;

function TLinearRGBAHelper.ToLChA: TLChA;
begin Result := LinearRGBAToLChA(Self) end;

function TLinearRGBAHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;
begin Result := LinearRGBAToLChA(Self,AReferenceWhite) end;

procedure TLinearRGBAHelper.FromColor(AValue: TColor);
begin Self := ColorToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromBGRAPixel(AValue: TBGRAPixel);
begin Self := BGRAPixelToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromExpandedPixel(AValue: TExpandedPixel);
begin Self := ExpandedPixelToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromHSLAPixel(AValue: THSLAPixel);
begin Self := HSLAPixelToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromGSBAPixel(AValue: TGSBAPixel);
begin Self := GSBAPixelToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromLabA(AValue: TLabA);
begin Self := LabAToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LabAToLinearRGBA(AValue,AReferenceWhite) end;

procedure TLinearRGBAHelper.FromLChA(AValue: TLChA);
begin Self := LChAToLinearRGBA(AValue) end;

procedure TLinearRGBAHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LChAToLinearRGBA(AValue,AReferenceWhite) end;

{THSLAPixelHelper}

{$IFDEF BDS}
function THSLAPixelHelper.ToColor: TColor;
begin
  result := BGRAToColor(HSLAToBGRA(self));
end;

procedure THSLAPixelHelper.FromColor(const AValue: TColor);
begin
  self := BGRAToHSLA(ColorToBGRA(AValue));
end;

function THSLAPixelHelper.ToBGRAPixel: TBGRAPixel;
begin
  result := HSLAToBGRA(self);
end;

procedure THSLAPixelHelper.FromBGRAPixel(AValue: TBGRAPixel);
begin
  self := BGRAToHSLA(AValue);
end;

function THSLAPixelHelper.ToGSBAPixel: TGSBAPixel;
begin
  result := HSLAToGSBA(self);
end;

procedure THSLAPixelHelper.FromGSBAPixel(AValue: TGSBAPixel);
begin
  self := GSBAToHSLA(AValue);
end;

function THSLAPixelHelper.ToExpanded: TExpandedPixel;
begin
  result := HSLAToExpanded(Self);
end;

procedure THSLAPixelHelper.FromExpanded(AValue: TExpandedPixel);
begin
  Self := ExpandedToHSLA(AValue);
end;
{$ENDIF}

class function THSLAPixelHelper.New(const AHue,ASaturation,ALightness,AAlpha:BGRAWord): THSLAPixel;
begin
  Result.hue := AHue;
  Result.saturation := ASaturation;
  Result.lightness := ALightness;
  Result.alpha := AAlpha;
end;

class function THSLAPixelHelper.New(const AHue,ASaturation,ALightness:BGRAWord): THSLAPixel;
begin
  Result.hue := AHue;
  Result.saturation := ASaturation;
  Result.lightness := ALightness;
  Result.alpha := 65535;
end;

class function THSLAPixelHelper.Colorspace: TColorspaceAny;
begin result := THSLAPixelColorspace end;

function THSLAPixelHelper.ToStdRGBA: TStdRGBA;
begin Result := HSLAPixelToStdRGBA(Self) end;

function THSLAPixelHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := HSLAPixelToAdobeRGBA(Self) end;

function THSLAPixelHelper.ToStdHSLA: TStdHSLA;
begin Result := HSLAPixelToStdHSLA(Self) end;

function THSLAPixelHelper.ToStdHSVA: TStdHSVA;
begin Result := HSLAPixelToStdHSVA(Self) end;

function THSLAPixelHelper.ToStdCMYK: TStdCMYK;
begin Result := HSLAPixelToStdCMYK(Self) end;

function THSLAPixelHelper.ToLinearRGBA: TLinearRGBA;
begin Result := HSLAPixelToLinearRGBA(Self) end;

function THSLAPixelHelper.ToXYZA: TXYZA;
begin Result := HSLAPixelToXYZA(Self) end;

function THSLAPixelHelper.ToLabA: TLabA;
begin Result := HSLAPixelToLabA(Self) end;

function THSLAPixelHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;
begin Result := HSLAPixelToLabA(Self,AReferenceWhite) end;

function THSLAPixelHelper.ToLChA: TLChA;
begin Result := HSLAPixelToLChA(Self) end;

function THSLAPixelHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;
begin Result := HSLAPixelToLChA(Self,AReferenceWhite) end;

procedure THSLAPixelHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToHSLAPixel(AValue) end;

procedure THSLAPixelHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToHSLAPixel(AValue) end;

procedure THSLAPixelHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToHSLAPixel(AValue) end;

procedure THSLAPixelHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToHSLAPixel(AValue) end;

procedure THSLAPixelHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToHSLAPixel(AValue) end;

procedure THSLAPixelHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToHSLAPixel(AValue) end;

procedure THSLAPixelHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToHSLAPixel(AValue) end;

procedure THSLAPixelHelper.FromLabA(AValue: TLabA);
begin Self := LabAToHSLAPixel(AValue) end;

procedure THSLAPixelHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LabAToHSLAPixel(AValue,AReferenceWhite) end;

procedure THSLAPixelHelper.FromLChA(AValue: TLChA);
begin Self := LChAToHSLAPixel(AValue) end;

procedure THSLAPixelHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LChAToHSLAPixel(AValue,AReferenceWhite) end;

{TGSBAPixelHelper}

class function TGSBAPixelHelper.New(const AHue,ASaturation,ABrightness,AAlpha:BGRAWord): TGSBAPixel;
begin
  Result.hue := AHue;
  Result.saturation := ASaturation;
  Result.lightness := ABrightness;
  Result.alpha := AAlpha;
end;

class function TGSBAPixelHelper.New(const AHue,ASaturation,ABrightness:BGRAWord): TGSBAPixel;
begin
  Result.hue := AHue;
  Result.saturation := ASaturation;
  Result.lightness := ABrightness;
  Result.alpha := 65535;
end;

class function TGSBAPixelHelper.Colorspace: TColorspaceAny;
begin result := TGSBAPixelColorspace end;

function TGSBAPixelHelper.ToStdRGBA: TStdRGBA;
begin Result := GSBAPixelToStdRGBA(Self) end;

function TGSBAPixelHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := GSBAPixelToAdobeRGBA(Self) end;

function TGSBAPixelHelper.ToStdHSLA: TStdHSLA;
begin Result := GSBAPixelToStdHSLA(Self) end;

function TGSBAPixelHelper.ToStdHSVA: TStdHSVA;
begin Result := GSBAPixelToStdHSVA(Self) end;

function TGSBAPixelHelper.ToStdCMYK: TStdCMYK;
begin Result := GSBAPixelToStdCMYK(Self) end;

function TGSBAPixelHelper.ToLinearRGBA: TLinearRGBA;
begin Result := GSBAPixelToLinearRGBA(Self) end;

function TGSBAPixelHelper.ToXYZA: TXYZA;
begin Result := GSBAPixelToXYZA(Self) end;

function TGSBAPixelHelper.ToLabA: TLabA;
begin Result := GSBAPixelToLabA(Self) end;

function TGSBAPixelHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;
begin Result := GSBAPixelToLabA(Self,AReferenceWhite) end;

function TGSBAPixelHelper.ToLChA: TLChA;
begin Result := GSBAPixelToLChA(Self) end;

function TGSBAPixelHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;
begin Result := GSBAPixelToLChA(Self,AReferenceWhite) end;

procedure TGSBAPixelHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToGSBAPixel(AValue) end;

procedure TGSBAPixelHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToGSBAPixel(AValue) end;

procedure TGSBAPixelHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToGSBAPixel(AValue) end;

procedure TGSBAPixelHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToGSBAPixel(AValue) end;

procedure TGSBAPixelHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToGSBAPixel(AValue) end;

procedure TGSBAPixelHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToGSBAPixel(AValue) end;

procedure TGSBAPixelHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToGSBAPixel(AValue) end;

procedure TGSBAPixelHelper.FromLabA(AValue: TLabA);
begin Self := LabAToGSBAPixel(AValue) end;

procedure TGSBAPixelHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LabAToGSBAPixel(AValue,AReferenceWhite) end;

procedure TGSBAPixelHelper.FromLChA(AValue: TLChA);
begin Self := LChAToGSBAPixel(AValue) end;

procedure TGSBAPixelHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LChAToGSBAPixel(AValue,AReferenceWhite) end;

{TXYZAHelper}

class function TXYZAHelper.Colorspace: TColorspaceAny;
begin result := TXYZAColorspace end;

function TXYZAHelper.ToColor: TColor;
begin Result := XYZAToColor(Self) end;

function TXYZAHelper.ToBGRAPixel: TBGRAPixel;
begin Result := XYZAToBGRAPixel(Self) end;

function TXYZAHelper.ToStdRGBA: TStdRGBA;
begin Result := XYZAToStdRGBA(Self) end;

function TXYZAHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(Self) end;

function TXYZAHelper.ToStdHSLA: TStdHSLA;
begin Result := XYZAToStdHSLA(Self) end;

function TXYZAHelper.ToStdHSVA: TStdHSVA;
begin Result := XYZAToStdHSVA(Self) end;

function TXYZAHelper.ToStdCMYK: TStdCMYK;
begin Result := XYZAToStdCMYK(Self) end;

function TXYZAHelper.ToExpandedPixel: TExpandedPixel;
begin Result := XYZAToExpandedPixel(Self) end;

function TXYZAHelper.ToLinearRGBA: TLinearRGBA;
begin Result := XYZAToLinearRGBA(Self) end;

function TXYZAHelper.ToHSLAPixel: THSLAPixel;
begin Result := XYZAToHSLAPixel(Self) end;

function TXYZAHelper.ToGSBAPixel: TGSBAPixel;
begin Result := XYZAToGSBAPixel(Self) end;

function TXYZAHelper.ToLabA: TLabA;
begin Result := XYZAToLabA(Self) end;

function TXYZAHelper.ToLabA(const AReferenceWhite: TXYZReferenceWhite): TLabA;
begin Result := XYZAToLabA(Self,AReferenceWhite) end;

function TXYZAHelper.ToLChA: TLChA;
begin Result := XYZAToLChA(Self) end;

function TXYZAHelper.ToLChA(const AReferenceWhite: TXYZReferenceWhite): TLChA;
begin Result := XYZAToLChA(Self,AReferenceWhite) end;

procedure TXYZAHelper.FromColor(AValue: TColor);
begin Self := ColorToXYZA(AValue) end;

procedure TXYZAHelper.FromBGRAPixel(AValue: TBGRAPixel);
begin Self := BGRAPixelToXYZA(AValue) end;

procedure TXYZAHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToXYZA(AValue) end;

procedure TXYZAHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToXYZA(AValue) end;

procedure TXYZAHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToXYZA(AValue) end;

procedure TXYZAHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToXYZA(AValue) end;

procedure TXYZAHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToXYZA(AValue) end;

procedure TXYZAHelper.FromExpandedPixel(AValue: TExpandedPixel);
begin Self := ExpandedPixelToXYZA(AValue) end;

procedure TXYZAHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToXYZA(AValue) end;

procedure TXYZAHelper.FromHSLAPixel(AValue: THSLAPixel);
begin Self := HSLAPixelToXYZA(AValue) end;

procedure TXYZAHelper.FromGSBAPixel(AValue: TGSBAPixel);
begin Self := GSBAPixelToXYZA(AValue) end;

procedure TXYZAHelper.FromLabA(AValue: TLabA);
begin Self := LabAToXYZA(AValue) end;

procedure TXYZAHelper.FromLabA(AValue: TLabA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LabAToXYZA(AValue,AReferenceWhite) end;

procedure TXYZAHelper.FromLChA(AValue: TLChA);
begin Self := LChAToXYZA(AValue) end;

procedure TXYZAHelper.FromLChA(AValue: TLChA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LChAToXYZA(AValue,AReferenceWhite) end;

{TLabAHelper}

class function TLabAHelper.Colorspace: TColorspaceAny;
begin result := TLabAColorspace end;

function TLabAHelper.ToColor: TColor;
begin Result := LabAToColor(Self) end;

function TLabAHelper.ToColor(const AReferenceWhite: TXYZReferenceWhite): TColor;
begin Result := LabAToColor(Self,AReferenceWhite) end;

function TLabAHelper.ToBGRAPixel: TBGRAPixel;
begin Result := LabAToBGRAPixel(Self) end;

function TLabAHelper.ToBGRAPixel(const AReferenceWhite: TXYZReferenceWhite): TBGRAPixel;
begin Result := LabAToBGRAPixel(Self,AReferenceWhite) end;

function TLabAHelper.ToStdRGBA: TStdRGBA;
begin Result := LabAToStdRGBA(Self) end;

function TLabAHelper.ToStdRGBA(const AReferenceWhite: TXYZReferenceWhite): TStdRGBA;
begin Result := LabAToStdRGBA(Self,AReferenceWhite) end;

function TLabAHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := LabAToAdobeRGBA(Self) end;

function TLabAHelper.ToAdobeRGBA(const AReferenceWhite: TXYZReferenceWhite): TAdobeRGBA;
begin Result := LabAToAdobeRGBA(Self,AReferenceWhite) end;

function TLabAHelper.ToStdHSLA: TStdHSLA;
begin Result := LabAToStdHSLA(Self) end;

function TLabAHelper.ToStdHSLA(const AReferenceWhite: TXYZReferenceWhite): TStdHSLA;
begin Result := LabAToStdHSLA(Self,AReferenceWhite) end;

function TLabAHelper.ToStdHSVA: TStdHSVA;
begin Result := LabAToStdHSVA(Self) end;

function TLabAHelper.ToStdHSVA(const AReferenceWhite: TXYZReferenceWhite): TStdHSVA;
begin Result := LabAToStdHSVA(Self,AReferenceWhite) end;

function TLabAHelper.ToStdCMYK: TStdCMYK;
begin Result := LabAToStdCMYK(Self) end;

function TLabAHelper.ToStdCMYK(const AReferenceWhite: TXYZReferenceWhite): TStdCMYK;
begin Result := LabAToStdCMYK(Self,AReferenceWhite) end;

function TLabAHelper.ToExpandedPixel: TExpandedPixel;
begin Result := LabAToExpandedPixel(Self) end;

function TLabAHelper.ToExpandedPixel(const AReferenceWhite: TXYZReferenceWhite): TExpandedPixel;
begin Result := LabAToExpandedPixel(Self,AReferenceWhite) end;

function TLabAHelper.ToLinearRGBA: TLinearRGBA;
begin Result := LabAToLinearRGBA(Self) end;

function TLabAHelper.ToLinearRGBA(const AReferenceWhite: TXYZReferenceWhite): TLinearRGBA;
begin Result := LabAToLinearRGBA(Self,AReferenceWhite) end;

function TLabAHelper.ToHSLAPixel: THSLAPixel;
begin Result := LabAToHSLAPixel(Self) end;

function TLabAHelper.ToHSLAPixel(const AReferenceWhite: TXYZReferenceWhite): THSLAPixel;
begin Result := LabAToHSLAPixel(Self,AReferenceWhite) end;

function TLabAHelper.ToGSBAPixel: TGSBAPixel;
begin Result := LabAToGSBAPixel(Self) end;

function TLabAHelper.ToGSBAPixel(const AReferenceWhite: TXYZReferenceWhite): TGSBAPixel;
begin Result := LabAToGSBAPixel(Self,AReferenceWhite) end;

function TLabAHelper.ToXYZA: TXYZA;
begin Result := LabAToXYZA(Self) end;

function TLabAHelper.ToXYZA(const AReferenceWhite: TXYZReferenceWhite): TXYZA;
begin Result := LabAToXYZA(Self,AReferenceWhite) end;

function TLabAHelper.ToLChA: TLChA;
begin Result := LabAToLChA(Self) end;

procedure TLabAHelper.FromColor(AValue: TColor);
begin Self := ColorToLabA(AValue) end;

procedure TLabAHelper.FromColor(AValue: TColor; const AReferenceWhite: TXYZReferenceWhite);
begin Self := ColorToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromBGRAPixel(AValue: TBGRAPixel);
begin Self := BGRAPixelToLabA(AValue) end;

procedure TLabAHelper.FromBGRAPixel(AValue: TBGRAPixel; const AReferenceWhite: TXYZReferenceWhite);
begin Self := BGRAPixelToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToLabA(AValue) end;

procedure TLabAHelper.FromStdRGBA(AValue: TStdRGBA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := StdRGBAToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToLabA(AValue) end;

procedure TLabAHelper.FromAdobeRGBA(AValue: TAdobeRGBA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := AdobeRGBAToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToLabA(AValue) end;

procedure TLabAHelper.FromStdHSLA(AValue: TStdHSLA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := StdHSLAToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToLabA(AValue) end;

procedure TLabAHelper.FromStdHSVA(AValue: TStdHSVA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := StdHSVAToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToLabA(AValue) end;

procedure TLabAHelper.FromStdCMYK(AValue: TStdCMYK; const AReferenceWhite: TXYZReferenceWhite);
begin Self := StdCMYKToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromExpandedPixel(AValue: TExpandedPixel);
begin Self := ExpandedPixelToLabA(AValue) end;

procedure TLabAHelper.FromExpandedPixel(AValue: TExpandedPixel; const AReferenceWhite: TXYZReferenceWhite);
begin Self := ExpandedPixelToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToLabA(AValue) end;

procedure TLabAHelper.FromLinearRGBA(AValue: TLinearRGBA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LinearRGBAToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromHSLAPixel(AValue: THSLAPixel);
begin Self := HSLAPixelToLabA(AValue) end;

procedure TLabAHelper.FromHSLAPixel(AValue: THSLAPixel; const AReferenceWhite: TXYZReferenceWhite);
begin Self := HSLAPixelToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromGSBAPixel(AValue: TGSBAPixel);
begin Self := GSBAPixelToLabA(AValue) end;

procedure TLabAHelper.FromGSBAPixel(AValue: TGSBAPixel; const AReferenceWhite: TXYZReferenceWhite);
begin Self := GSBAPixelToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToLabA(AValue) end;

procedure TLabAHelper.FromXYZA(AValue: TXYZA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := XYZAToLabA(AValue,AReferenceWhite) end;

procedure TLabAHelper.FromLChA(AValue: TLChA);
begin Self := LChAToLabA(AValue) end;

{TLChAHelper}

class function TLChAHelper.Colorspace: TColorspaceAny;
begin result := TLChAColorspace end;

function TLChAHelper.ToColor: TColor;
begin Result := LChAToColor(Self) end;

function TLChAHelper.ToColor(const AReferenceWhite: TXYZReferenceWhite): TColor;
begin Result := LChAToColor(Self,AReferenceWhite) end;

function TLChAHelper.ToBGRAPixel: TBGRAPixel;
begin Result := LChAToBGRAPixel(Self) end;

function TLChAHelper.ToBGRAPixel(const AReferenceWhite: TXYZReferenceWhite): TBGRAPixel;
begin Result := LChAToBGRAPixel(Self,AReferenceWhite) end;

function TLChAHelper.ToStdRGBA: TStdRGBA;
begin Result := LChAToStdRGBA(Self) end;

function TLChAHelper.ToStdRGBA(const AReferenceWhite: TXYZReferenceWhite): TStdRGBA;
begin Result := LChAToStdRGBA(Self,AReferenceWhite) end;

function TLChAHelper.ToAdobeRGBA: TAdobeRGBA;
begin Result := LChAToAdobeRGBA(Self) end;

function TLChAHelper.ToAdobeRGBA(const AReferenceWhite: TXYZReferenceWhite): TAdobeRGBA;
begin Result := LChAToAdobeRGBA(Self,AReferenceWhite) end;

function TLChAHelper.ToStdHSLA: TStdHSLA;
begin Result := LChAToStdHSLA(Self) end;

function TLChAHelper.ToStdHSLA(const AReferenceWhite: TXYZReferenceWhite): TStdHSLA;
begin Result := LChAToStdHSLA(Self,AReferenceWhite) end;

function TLChAHelper.ToStdHSVA: TStdHSVA;
begin Result := LChAToStdHSVA(Self) end;

function TLChAHelper.ToStdHSVA(const AReferenceWhite: TXYZReferenceWhite): TStdHSVA;
begin Result := LChAToStdHSVA(Self,AReferenceWhite) end;

function TLChAHelper.ToStdCMYK: TStdCMYK;
begin Result := LChAToStdCMYK(Self) end;

function TLChAHelper.ToStdCMYK(const AReferenceWhite: TXYZReferenceWhite): TStdCMYK;
begin Result := LChAToStdCMYK(Self,AReferenceWhite) end;

function TLChAHelper.ToExpandedPixel: TExpandedPixel;
begin Result := LChAToExpandedPixel(Self) end;

function TLChAHelper.ToExpandedPixel(const AReferenceWhite: TXYZReferenceWhite): TExpandedPixel;
begin Result := LChAToExpandedPixel(Self,AReferenceWhite) end;

function TLChAHelper.ToLinearRGBA: TLinearRGBA;
begin Result := LChAToLinearRGBA(Self) end;

function TLChAHelper.ToLinearRGBA(const AReferenceWhite: TXYZReferenceWhite): TLinearRGBA;
begin Result := LChAToLinearRGBA(Self,AReferenceWhite) end;

function TLChAHelper.ToHSLAPixel: THSLAPixel;
begin Result := LChAToHSLAPixel(Self) end;

function TLChAHelper.ToHSLAPixel(const AReferenceWhite: TXYZReferenceWhite): THSLAPixel;
begin Result := LChAToHSLAPixel(Self,AReferenceWhite) end;

function TLChAHelper.ToGSBAPixel: TGSBAPixel;
begin Result := LChAToGSBAPixel(Self) end;

function TLChAHelper.ToGSBAPixel(const AReferenceWhite: TXYZReferenceWhite): TGSBAPixel;
begin Result := LChAToGSBAPixel(Self,AReferenceWhite) end;

function TLChAHelper.ToXYZA: TXYZA;
begin Result := LChAToXYZA(Self) end;

function TLChAHelper.ToXYZA(const AReferenceWhite: TXYZReferenceWhite): TXYZA;
begin Result := LChAToXYZA(Self,AReferenceWhite) end;

function TLChAHelper.ToLabA: TLabA;
begin Result := LChAToLabA(Self) end;

procedure TLChAHelper.FromColor(AValue: TColor);
begin Self := ColorToLChA(AValue) end;

procedure TLChAHelper.FromColor(AValue: TColor; const AReferenceWhite: TXYZReferenceWhite);
begin Self := ColorToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromBGRAPixel(AValue: TBGRAPixel);
begin Self := BGRAPixelToLChA(AValue) end;

procedure TLChAHelper.FromBGRAPixel(AValue: TBGRAPixel; const AReferenceWhite: TXYZReferenceWhite);
begin Self := BGRAPixelToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromStdRGBA(AValue: TStdRGBA);
begin Self := StdRGBAToLChA(AValue) end;

procedure TLChAHelper.FromStdRGBA(AValue: TStdRGBA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := StdRGBAToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromAdobeRGBA(AValue: TAdobeRGBA);
begin Self := AdobeRGBAToLChA(AValue) end;

procedure TLChAHelper.FromAdobeRGBA(AValue: TAdobeRGBA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := AdobeRGBAToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromStdHSLA(AValue: TStdHSLA);
begin Self := StdHSLAToLChA(AValue) end;

procedure TLChAHelper.FromStdHSLA(AValue: TStdHSLA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := StdHSLAToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromStdHSVA(AValue: TStdHSVA);
begin Self := StdHSVAToLChA(AValue) end;

procedure TLChAHelper.FromStdHSVA(AValue: TStdHSVA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := StdHSVAToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromStdCMYK(AValue: TStdCMYK);
begin Self := StdCMYKToLChA(AValue) end;

procedure TLChAHelper.FromStdCMYK(AValue: TStdCMYK; const AReferenceWhite: TXYZReferenceWhite);
begin Self := StdCMYKToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromExpandedPixel(AValue: TExpandedPixel);
begin Self := ExpandedPixelToLChA(AValue) end;

procedure TLChAHelper.FromExpandedPixel(AValue: TExpandedPixel; const AReferenceWhite: TXYZReferenceWhite);
begin Self := ExpandedPixelToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromLinearRGBA(AValue: TLinearRGBA);
begin Self := LinearRGBAToLChA(AValue) end;

procedure TLChAHelper.FromLinearRGBA(AValue: TLinearRGBA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := LinearRGBAToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromHSLAPixel(AValue: THSLAPixel);
begin Self := HSLAPixelToLChA(AValue) end;

procedure TLChAHelper.FromHSLAPixel(AValue: THSLAPixel; const AReferenceWhite: TXYZReferenceWhite);
begin Self := HSLAPixelToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromGSBAPixel(AValue: TGSBAPixel);
begin Self := GSBAPixelToLChA(AValue) end;

procedure TLChAHelper.FromGSBAPixel(AValue: TGSBAPixel; const AReferenceWhite: TXYZReferenceWhite);
begin Self := GSBAPixelToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromXYZA(AValue: TXYZA);
begin Self := XYZAToLChA(AValue) end;

procedure TLChAHelper.FromXYZA(AValue: TXYZA; const AReferenceWhite: TXYZReferenceWhite);
begin Self := XYZAToLChA(AValue,AReferenceWhite) end;

procedure TLChAHelper.FromLabA(AValue: TLabA);
begin Self := LabAToLChA(AValue) end;

{Operators}

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor): TStdRGBA;
begin Result := ColorToStdRGBA(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor): TAdobeRGBA;
begin Result := ColorToAdobeRGBA(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor): TStdHSLA;
begin Result := ColorToStdHSLA(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor): TStdHSVA;
begin Result := ColorToStdHSVA(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor): TStdCMYK;
begin Result := ColorToStdCMYK(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor): TLinearRGBA;
begin Result := ColorToLinearRGBA(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor): TXYZA;
begin Result := ColorToXYZA(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor): TLabA;
begin Result := ColorToLabA(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TColor): TLChA;
begin Result := ColorToLChA(AValue) end;

//
{$IFDEF OBJ}
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel): PStdRGBA;
begin Result^ := BGRAPixelToStdRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel): PAdobeRGBA;
begin Result^ := BGRAPixelToAdobeRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel): PStdHSLA;
begin Result^ := BGRAPixelToStdHSLA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel): PStdHSVA;
begin Result^ := BGRAPixelToStdHSVA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel): PStdCMYK;
begin Result^ := BGRAPixelToStdCMYK(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel): PLinearRGBA;
begin Result^ := BGRAPixelToLinearRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel): PXYZA;
begin Result^ := BGRAPixelToXYZA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel): PLabA;
begin Result^ := BGRAPixelToLabA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TBGRAPixel): PLChA;
begin Result^ := BGRAPixelToLChA(AValue) end;
{$ENDIF}
//

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): PLinearRGBA;
begin Result^ := StdRGBAToLinearRGBA(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): PAdobeRGBA;
begin Result^ := StdRGBAToAdobeRGBA(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): PStdHSLA;
begin Result^ := StdRGBAToStdHSLA(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): PStdHSVA;
begin Result^ := StdRGBAToStdHSVA(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): PStdCMYK;
begin Result^ := StdRGBAToStdCMYK(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): PXYZA;
begin Result^ := StdRGBAToXYZA(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): PLabA;
begin Result^ := StdRGBAToLabA(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): PLChA;
begin Result^ := StdRGBAToLChA(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): TColor;
begin Result := StdRGBAToColor(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): TBGRAPixel;
begin Result := StdRGBAToBGRAPixel(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): TExpandedPixel;
begin Result := StdRGBAToExpandedPixel(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): THSLAPixel;
begin Result := StdRGBAToHSLAPixel(AValue) end;

class operator TStdRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdRGBA): TGSBAPixel;
begin Result := StdRGBAToGSBAPixel(AValue) end;

//

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): PStdHSLA;
begin Result^ := AdobeRGBAToStdHSLA(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): PStdHSVA;
begin Result^ := AdobeRGBAToStdHSVA(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): PStdCMYK;
begin Result^ := AdobeRGBAToStdCMYK(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): PLinearRGBA;
begin Result^ := AdobeRGBAToLinearRGBA(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): PXYZA;
begin Result^ := AdobeRGBAToXYZA(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): PLabA;
begin Result^ := AdobeRGBAToLabA(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): PLChA;
begin Result^ := AdobeRGBAToLChA(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): TColor;
begin Result := AdobeRGBAToColor(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): TBGRAPixel;
begin Result := AdobeRGBAToBGRAPixel(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): TStdRGBA;
begin Result := AdobeRGBAToStdRGBA(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): TExpandedPixel;
begin Result := AdobeRGBAToExpandedPixel(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): THSLAPixel;
begin Result := AdobeRGBAToHSLAPixel(AValue) end;

class operator TAdobeRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TAdobeRGBA): TGSBAPixel;
begin Result := AdobeRGBAToGSBAPixel(AValue) end;

//

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): PStdHSVA;
begin Result^ := StdHSLAToStdHSVA(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): PStdCMYK;
begin Result^ := StdHSLAToStdCMYK(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): PLinearRGBA;
begin Result^ := StdHSLAToLinearRGBA(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): PXYZA;
begin Result^ := StdHSLAToXYZA(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): PLabA;
begin Result^ := StdHSLAToLabA(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): PLChA;
begin Result^ := StdHSLAToLChA(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): TColor;
begin Result := StdHSLAToColor(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): TBGRAPixel;
begin Result := StdHSLAToBGRAPixel(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): TStdRGBA;
begin Result := StdHSLAToStdRGBA(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): TAdobeRGBA;
begin Result := StdHSLAToAdobeRGBA(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): TExpandedPixel;
begin Result := StdHSLAToExpandedPixel(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): THSLAPixel;
begin Result := StdHSLAToHSLAPixel(AValue) end;

class operator TStdHSLA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSLA): TGSBAPixel;
begin Result := StdHSLAToGSBAPixel(AValue) end;

//

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): PStdCMYK;
begin Result^ := StdHSVAToStdCMYK(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): PLinearRGBA;
begin Result^ := StdHSVAToLinearRGBA(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): PXYZA;
begin Result^ := StdHSVAToXYZA(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): PLabA;
begin Result^ := StdHSVAToLabA(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): PLChA;
begin Result^ := StdHSVAToLChA(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): TColor;
begin Result := StdHSVAToColor(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): TBGRAPixel;
begin Result := StdHSVAToBGRAPixel(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): TStdRGBA;
begin Result := StdHSVAToStdRGBA(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): TAdobeRGBA;
begin Result := StdHSVAToAdobeRGBA(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): TStdHSLA;
begin Result := StdHSVAToStdHSLA(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): TExpandedPixel;
begin Result := StdHSVAToExpandedPixel(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): THSLAPixel;
begin Result := StdHSVAToHSLAPixel(AValue) end;

class operator TStdHSVA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdHSVA): TGSBAPixel;
begin Result := StdHSVAToGSBAPixel(AValue) end;

//

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): PLinearRGBA;
begin Result^ := StdCMYKToLinearRGBA(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): PXYZA;
begin Result^ := StdCMYKToXYZA(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): PLabA;
begin Result^ := StdCMYKToLabA(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): PLChA;
begin Result^ := StdCMYKToLChA(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): TColor;
begin Result := StdCMYKToColor(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): TBGRAPixel;
begin Result := StdCMYKToBGRAPixel(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): TStdRGBA;
begin Result := StdCMYKToStdRGBA(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): TAdobeRGBA;
begin Result := StdCMYKToAdobeRGBA(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): TStdHSLA;
begin Result := StdCMYKToStdHSLA(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): TStdHSVA;
begin Result := StdCMYKToStdHSVA(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): TExpandedPixel;
begin Result := StdCMYKToExpandedPixel(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): THSLAPixel;
begin Result := StdCMYKToHSLAPixel(AValue) end;

class operator TStdCMYK.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TStdCMYK): TGSBAPixel;
begin Result := StdCMYKToGSBAPixel(AValue) end;

//
{$IFDEF OBJ}
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PStdRGBA;
begin Result^ := ExpandedPixelToStdRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PAdobeRGBA;
begin Result^ := ExpandedPixelToAdobeRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PStdHSLA;
begin Result^ := ExpandedPixelToStdHSLA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PStdHSVA;
begin Result^ := ExpandedPixelToStdHSVA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PStdCMYK;
begin Result^ := ExpandedPixelToStdCMYK(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PLinearRGBA;
begin Result^ := ExpandedPixelToLinearRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PXYZA;
begin Result^ := ExpandedPixelToXYZA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PLabA;
begin Result^ := ExpandedPixelToLabA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TExpandedPixel): PLChA;
begin Result^ := ExpandedPixelToLChA(AValue) end;
{$ENDIF}

//

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): PXYZA;
begin Result^ := LinearRGBAToXYZA(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): PLabA;
begin Result^ := LinearRGBAToLabA(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): PLChA;
begin Result^ := LinearRGBAToLChA(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): TColor;
begin Result := LinearRGBAToColor(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): TBGRAPixel;
begin Result := LinearRGBAToBGRAPixel(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): TStdRGBA;
begin Result := LinearRGBAToStdRGBA(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): TAdobeRGBA;
begin Result := LinearRGBAToAdobeRGBA(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): TStdHSLA;
begin Result := LinearRGBAToStdHSLA(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): TStdHSVA;
begin Result := LinearRGBAToStdHSVA(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): TStdCMYK;
begin Result := LinearRGBAToStdCMYK(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): TExpandedPixel;
begin Result := LinearRGBAToExpandedPixel(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): THSLAPixel;
begin Result := LinearRGBAToHSLAPixel(AValue) end;

class operator TLinearRGBA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLinearRGBA): TGSBAPixel;
begin Result := LinearRGBAToGSBAPixel(AValue) end;

//
{$IFDEF OBJ}
Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel): PStdRGBA;
begin Result^ := HSLAPixelToStdRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel): PAdobeRGBA;
begin Result^ := HSLAPixelToAdobeRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel): PStdHSLA;
begin Result^ := HSLAPixelToStdHSLA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel): PStdHSVA;
begin Result^ := HSLAPixelToStdHSVA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel): PStdCMYK;
begin Result^ := HSLAPixelToStdCMYK(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel): PLinearRGBA;
begin Result^ := HSLAPixelToLinearRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel): PXYZA;
begin Result^ := HSLAPixelToXYZA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel): PLabA;
begin Result^ := HSLAPixelToLabA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: THSLAPixel): PLChA;
begin Result^ := HSLAPixelToLChA(AValue) end;

//

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel): PStdRGBA;
begin Result^ := GSBAPixelToStdRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel): PAdobeRGBA;
begin Result^ := GSBAPixelToAdobeRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel): PStdHSLA;
begin Result^ := GSBAPixelToStdHSLA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel): PStdHSVA;
begin Result^ := GSBAPixelToStdHSVA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel): PStdCMYK;
begin Result^ := GSBAPixelToStdCMYK(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel): PLinearRGBA;
begin Result^ := GSBAPixelToLinearRGBA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel): PXYZA;
begin Result^ := GSBAPixelToXYZA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel): PLabA;
begin Result^ := GSBAPixelToLabA(AValue) end;

Operator  {$IFDEF OBJ} := {$ELSE} Implicit {$ENDIF}(const AValue: TGSBAPixel): PLChA;
begin Result^ := GSBAPixelToLChA(AValue) end;
{$ENDIF}

//

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): PLabA;
begin Result^ := XYZAToLabA(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): PLChA;
begin Result^ := XYZAToLChA(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): TColor;
begin Result := XYZAToColor(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): TBGRAPixel;
begin Result := XYZAToBGRAPixel(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): TStdRGBA;
begin Result := XYZAToStdRGBA(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): TAdobeRGBA;
begin Result := XYZAToAdobeRGBA(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): TStdHSLA;
begin Result := XYZAToStdHSLA(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): TStdHSVA;
begin Result := XYZAToStdHSVA(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): TStdCMYK;
begin Result := XYZAToStdCMYK(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): TExpandedPixel;
begin Result := XYZAToExpandedPixel(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): TLinearRGBA;
begin Result := XYZAToLinearRGBA(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): THSLAPixel;
begin Result := XYZAToHSLAPixel(AValue) end;

class operator TXYZA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TXYZA): TGSBAPixel;
begin Result := XYZAToGSBAPixel(AValue) end;

//

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): PLChA;
begin Result^ := LabAToLChA(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): TColor;
begin Result := LabAToColor(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): TBGRAPixel;
begin Result := LabAToBGRAPixel(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): TStdRGBA;
begin Result := LabAToStdRGBA(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): TAdobeRGBA;
begin Result := LabAToAdobeRGBA(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): TStdHSLA;
begin Result := LabAToStdHSLA(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): TStdHSVA;
begin Result := LabAToStdHSVA(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): TStdCMYK;
begin Result := LabAToStdCMYK(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): TExpandedPixel;
begin Result := LabAToExpandedPixel(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): TLinearRGBA;
begin Result := LabAToLinearRGBA(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): THSLAPixel;
begin Result := LabAToHSLAPixel(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): TGSBAPixel;
begin Result := LabAToGSBAPixel(AValue) end;

class operator TLabA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLabA): TXYZA;
begin Result := LabAToXYZA(AValue) end;

//

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TColor;
begin Result := LChAToColor(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TBGRAPixel;
begin Result := LChAToBGRAPixel(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TStdRGBA;
begin Result := LChAToStdRGBA(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TAdobeRGBA;
begin Result := LChAToAdobeRGBA(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TStdHSLA;
begin Result := LChAToStdHSLA(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TStdHSVA;
begin Result := LChAToStdHSVA(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TStdCMYK;
begin Result := LChAToStdCMYK(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TExpandedPixel;
begin Result := LChAToExpandedPixel(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TLinearRGBA;
begin Result := LChAToLinearRGBA(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): THSLAPixel;
begin Result := LChAToHSLAPixel(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TGSBAPixel;
begin Result := LChAToGSBAPixel(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TXYZA;
begin Result := LChAToXYZA(AValue) end;

class operator TLChA.{$IFDEF OBJ}:={$ELSE}Implicit{$ENDIF}(const AValue: TLChA): TLabA;
begin Result := LChAToLabA(AValue) end;

{$ENDIF}
{$IFDEF INCLUDE_INITIALIZATION}
{$UNDEF INCLUDE_INITIALIZATION}
  ColorspaceCollection.Add(TColorColorspace);
  ColorspaceCollection.Add(TBGRAPixelColorspace);
  ColorspaceCollection.Add(TStdRGBAColorspace);
  ColorspaceCollection.Add(TAdobeRGBAColorspace);
  ColorspaceCollection.Add(TStdHSLAColorspace);
  ColorspaceCollection.Add(TStdHSVAColorspace);
  ColorspaceCollection.Add(TStdCMYKColorspace);
  ColorspaceCollection.Add(TExpandedPixelColorspace);
  ColorspaceCollection.Add(TLinearRGBAColorspace);
  ColorspaceCollection.Add(THSLAPixelColorspace);
  ColorspaceCollection.Add(TGSBAPixelColorspace);
  ColorspaceCollection.Add(TXYZAColorspace);
  ColorspaceCollection.Add(TLabAColorspace);
  ColorspaceCollection.Add(TLChAColorspace);
  ColorspaceCollection.AddConversion(TColorColorspace, TBGRAPixelColorspace, @ConvertColorArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TColorColorspace, TStdRGBAColorspace, @ConvertColorArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TColorColorspace, TAdobeRGBAColorspace, @ConvertColorArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TColorColorspace, TStdHSLAColorspace, @ConvertColorArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TColorColorspace, TStdHSVAColorspace, @ConvertColorArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TColorColorspace, TStdCMYKColorspace, @ConvertColorArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TColorColorspace, TExpandedPixelColorspace, @ConvertColorArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TColorColorspace, TLinearRGBAColorspace, @ConvertColorArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TColorColorspace, THSLAPixelColorspace, @ConvertColorArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TColorColorspace, TGSBAPixelColorspace, @ConvertColorArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TColorColorspace, TXYZAColorspace, @ConvertColorArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TColorColorspace, TLabAColorspace, @ConvertColorArrayToLabAArray);
  ColorspaceCollection.AddConversion(TColorColorspace, TLChAColorspace, @ConvertColorArrayToLChAArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TColorColorspace, @ConvertBGRAPixelArrayToColorArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TStdRGBAColorspace, @ConvertBGRAPixelArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TAdobeRGBAColorspace, @ConvertBGRAPixelArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TStdHSLAColorspace, @ConvertBGRAPixelArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TStdHSVAColorspace, @ConvertBGRAPixelArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TStdCMYKColorspace, @ConvertBGRAPixelArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TExpandedPixelColorspace, @ConvertBGRAPixelArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TLinearRGBAColorspace, @ConvertBGRAPixelArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, THSLAPixelColorspace, @ConvertBGRAPixelArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TGSBAPixelColorspace, @ConvertBGRAPixelArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TXYZAColorspace, @ConvertBGRAPixelArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TLabAColorspace, @ConvertBGRAPixelArrayToLabAArray);
  ColorspaceCollection.AddConversion(TBGRAPixelColorspace, TLChAColorspace, @ConvertBGRAPixelArrayToLChAArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TColorColorspace, @ConvertStdRGBAArrayToColorArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TBGRAPixelColorspace, @ConvertStdRGBAArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TAdobeRGBAColorspace, @ConvertStdRGBAArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TStdHSLAColorspace, @ConvertStdRGBAArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TStdHSVAColorspace, @ConvertStdRGBAArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TStdCMYKColorspace, @ConvertStdRGBAArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TExpandedPixelColorspace, @ConvertStdRGBAArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TLinearRGBAColorspace, @ConvertStdRGBAArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, THSLAPixelColorspace, @ConvertStdRGBAArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TGSBAPixelColorspace, @ConvertStdRGBAArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TXYZAColorspace, @ConvertStdRGBAArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TLabAColorspace, @ConvertStdRGBAArrayToLabAArray);
  ColorspaceCollection.AddConversion(TStdRGBAColorspace, TLChAColorspace, @ConvertStdRGBAArrayToLChAArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TColorColorspace, @ConvertAdobeRGBAArrayToColorArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TBGRAPixelColorspace, @ConvertAdobeRGBAArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TStdRGBAColorspace, @ConvertAdobeRGBAArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TStdHSLAColorspace, @ConvertAdobeRGBAArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TStdHSVAColorspace, @ConvertAdobeRGBAArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TStdCMYKColorspace, @ConvertAdobeRGBAArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TExpandedPixelColorspace, @ConvertAdobeRGBAArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TLinearRGBAColorspace, @ConvertAdobeRGBAArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, THSLAPixelColorspace, @ConvertAdobeRGBAArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TGSBAPixelColorspace, @ConvertAdobeRGBAArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TXYZAColorspace, @ConvertAdobeRGBAArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TLabAColorspace, @ConvertAdobeRGBAArrayToLabAArray);
  ColorspaceCollection.AddConversion(TAdobeRGBAColorspace, TLChAColorspace, @ConvertAdobeRGBAArrayToLChAArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TColorColorspace, @ConvertStdHSLAArrayToColorArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TBGRAPixelColorspace, @ConvertStdHSLAArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TStdRGBAColorspace, @ConvertStdHSLAArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TAdobeRGBAColorspace, @ConvertStdHSLAArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TStdHSVAColorspace, @ConvertStdHSLAArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TStdCMYKColorspace, @ConvertStdHSLAArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TExpandedPixelColorspace, @ConvertStdHSLAArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TLinearRGBAColorspace, @ConvertStdHSLAArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, THSLAPixelColorspace, @ConvertStdHSLAArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TGSBAPixelColorspace, @ConvertStdHSLAArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TXYZAColorspace, @ConvertStdHSLAArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TLabAColorspace, @ConvertStdHSLAArrayToLabAArray);
  ColorspaceCollection.AddConversion(TStdHSLAColorspace, TLChAColorspace, @ConvertStdHSLAArrayToLChAArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TColorColorspace, @ConvertStdHSVAArrayToColorArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TBGRAPixelColorspace, @ConvertStdHSVAArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TStdRGBAColorspace, @ConvertStdHSVAArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TAdobeRGBAColorspace, @ConvertStdHSVAArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TStdHSLAColorspace, @ConvertStdHSVAArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TStdCMYKColorspace, @ConvertStdHSVAArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TExpandedPixelColorspace, @ConvertStdHSVAArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TLinearRGBAColorspace, @ConvertStdHSVAArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, THSLAPixelColorspace, @ConvertStdHSVAArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TGSBAPixelColorspace, @ConvertStdHSVAArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TXYZAColorspace, @ConvertStdHSVAArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TLabAColorspace, @ConvertStdHSVAArrayToLabAArray);
  ColorspaceCollection.AddConversion(TStdHSVAColorspace, TLChAColorspace, @ConvertStdHSVAArrayToLChAArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TColorColorspace, @ConvertStdCMYKArrayToColorArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TBGRAPixelColorspace, @ConvertStdCMYKArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TStdRGBAColorspace, @ConvertStdCMYKArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TAdobeRGBAColorspace, @ConvertStdCMYKArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TStdHSLAColorspace, @ConvertStdCMYKArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TStdHSVAColorspace, @ConvertStdCMYKArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TExpandedPixelColorspace, @ConvertStdCMYKArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TLinearRGBAColorspace, @ConvertStdCMYKArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, THSLAPixelColorspace, @ConvertStdCMYKArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TGSBAPixelColorspace, @ConvertStdCMYKArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TXYZAColorspace, @ConvertStdCMYKArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TLabAColorspace, @ConvertStdCMYKArrayToLabAArray);
  ColorspaceCollection.AddConversion(TStdCMYKColorspace, TLChAColorspace, @ConvertStdCMYKArrayToLChAArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TColorColorspace, @ConvertExpandedPixelArrayToColorArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TBGRAPixelColorspace, @ConvertExpandedPixelArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TStdRGBAColorspace, @ConvertExpandedPixelArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TAdobeRGBAColorspace, @ConvertExpandedPixelArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TStdHSLAColorspace, @ConvertExpandedPixelArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TStdHSVAColorspace, @ConvertExpandedPixelArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TStdCMYKColorspace, @ConvertExpandedPixelArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TLinearRGBAColorspace, @ConvertExpandedPixelArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, THSLAPixelColorspace, @ConvertExpandedPixelArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TGSBAPixelColorspace, @ConvertExpandedPixelArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TXYZAColorspace, @ConvertExpandedPixelArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TLabAColorspace, @ConvertExpandedPixelArrayToLabAArray);
  ColorspaceCollection.AddConversion(TExpandedPixelColorspace, TLChAColorspace, @ConvertExpandedPixelArrayToLChAArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TColorColorspace, @ConvertLinearRGBAArrayToColorArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TBGRAPixelColorspace, @ConvertLinearRGBAArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TStdRGBAColorspace, @ConvertLinearRGBAArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TAdobeRGBAColorspace, @ConvertLinearRGBAArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TStdHSLAColorspace, @ConvertLinearRGBAArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TStdHSVAColorspace, @ConvertLinearRGBAArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TStdCMYKColorspace, @ConvertLinearRGBAArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TExpandedPixelColorspace, @ConvertLinearRGBAArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, THSLAPixelColorspace, @ConvertLinearRGBAArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TGSBAPixelColorspace, @ConvertLinearRGBAArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TXYZAColorspace, @ConvertLinearRGBAArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TLabAColorspace, @ConvertLinearRGBAArrayToLabAArray);
  ColorspaceCollection.AddConversion(TLinearRGBAColorspace, TLChAColorspace, @ConvertLinearRGBAArrayToLChAArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TColorColorspace, @ConvertHSLAPixelArrayToColorArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TBGRAPixelColorspace, @ConvertHSLAPixelArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TStdRGBAColorspace, @ConvertHSLAPixelArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TAdobeRGBAColorspace, @ConvertHSLAPixelArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TStdHSLAColorspace, @ConvertHSLAPixelArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TStdHSVAColorspace, @ConvertHSLAPixelArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TStdCMYKColorspace, @ConvertHSLAPixelArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TExpandedPixelColorspace, @ConvertHSLAPixelArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TLinearRGBAColorspace, @ConvertHSLAPixelArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TGSBAPixelColorspace, @ConvertHSLAPixelArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TXYZAColorspace, @ConvertHSLAPixelArrayToXYZAArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TLabAColorspace, @ConvertHSLAPixelArrayToLabAArray);
  ColorspaceCollection.AddConversion(THSLAPixelColorspace, TLChAColorspace, @ConvertHSLAPixelArrayToLChAArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TColorColorspace, @ConvertGSBAPixelArrayToColorArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TBGRAPixelColorspace, @ConvertGSBAPixelArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TStdRGBAColorspace, @ConvertGSBAPixelArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TAdobeRGBAColorspace, @ConvertGSBAPixelArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TStdHSLAColorspace, @ConvertGSBAPixelArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TStdHSVAColorspace, @ConvertGSBAPixelArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TStdCMYKColorspace, @ConvertGSBAPixelArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TExpandedPixelColorspace, @ConvertGSBAPixelArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TLinearRGBAColorspace, @ConvertGSBAPixelArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, THSLAPixelColorspace, @ConvertGSBAPixelArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TXYZAColorspace, @ConvertGSBAPixelArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TLabAColorspace, @ConvertGSBAPixelArrayToLabAArray);
  ColorspaceCollection.AddConversion(TGSBAPixelColorspace, TLChAColorspace, @ConvertGSBAPixelArrayToLChAArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TColorColorspace, @ConvertXYZAArrayToColorArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TBGRAPixelColorspace, @ConvertXYZAArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TStdRGBAColorspace, @ConvertXYZAArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TAdobeRGBAColorspace, @ConvertXYZAArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TStdHSLAColorspace, @ConvertXYZAArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TStdHSVAColorspace, @ConvertXYZAArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TStdCMYKColorspace, @ConvertXYZAArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TExpandedPixelColorspace, @ConvertXYZAArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TLinearRGBAColorspace, @ConvertXYZAArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, THSLAPixelColorspace, @ConvertXYZAArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TGSBAPixelColorspace, @ConvertXYZAArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TLabAColorspace, @ConvertXYZAArrayToLabAArray);
  ColorspaceCollection.AddConversion(TXYZAColorspace, TLChAColorspace, @ConvertXYZAArrayToLChAArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TColorColorspace, @ConvertLabAArrayToColorArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TBGRAPixelColorspace, @ConvertLabAArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TStdRGBAColorspace, @ConvertLabAArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TAdobeRGBAColorspace, @ConvertLabAArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TStdHSLAColorspace, @ConvertLabAArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TStdHSVAColorspace, @ConvertLabAArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TStdCMYKColorspace, @ConvertLabAArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TExpandedPixelColorspace, @ConvertLabAArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TLinearRGBAColorspace, @ConvertLabAArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, THSLAPixelColorspace, @ConvertLabAArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TGSBAPixelColorspace, @ConvertLabAArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TXYZAColorspace, @ConvertLabAArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TLabAColorspace, TLChAColorspace, @ConvertLabAArrayToLChAArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TColorColorspace, @ConvertLChAArrayToColorArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TBGRAPixelColorspace, @ConvertLChAArrayToBGRAPixelArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TStdRGBAColorspace, @ConvertLChAArrayToStdRGBAArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TAdobeRGBAColorspace, @ConvertLChAArrayToAdobeRGBAArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TStdHSLAColorspace, @ConvertLChAArrayToStdHSLAArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TStdHSVAColorspace, @ConvertLChAArrayToStdHSVAArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TStdCMYKColorspace, @ConvertLChAArrayToStdCMYKArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TExpandedPixelColorspace, @ConvertLChAArrayToExpandedPixelArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TLinearRGBAColorspace, @ConvertLChAArrayToLinearRGBAArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, THSLAPixelColorspace, @ConvertLChAArrayToHSLAPixelArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TGSBAPixelColorspace, @ConvertLChAArrayToGSBAPixelArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TXYZAColorspace, @ConvertLChAArrayToXYZAArray);
  ColorspaceCollection.AddConversion(TLChAColorspace, TLabAColorspace, @ConvertLChAArrayToLabAArray);
{$ENDIF}
